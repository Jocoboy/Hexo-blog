<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>领域驱动设计与ABP框架</title>
    <url>/Hexo-Blog/2024/08/13/abp-and-ddd/</url>
    <content><![CDATA[<p>领域驱动设计核心概念与ABP框架实践。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ABP框架基于.NET和ASP.NET Core，是对领域驱动设计(Domain Driven Design，简称DDD)的一种实现，主要目标是为应用程序开发引入的一种架构方法。</p>
<blockquote>
<ul>
<li>.NET Framework仅支持Windows平台，适用于传统的Windows桌面和Web应用开发</li>
<li>.NET Core是一个全新的、从头开发的.NET 实现，支持跨平台，适用于构建现代化的云原生应用、微服务、跨平台应用等</li>
<li>.NET融合了.NET Core和.NET Framework的优点，支持跨平台，适用于各种类型的应用开发，包括桌面应用、Web 应用、云服务、移动应用等</li>
<li>ASP.NET是一个Web应用程序开发框架，仅支持Windows平台，使用.NET Framework运行时</li>
<li>ASP.NET Core是对ASP.NET的重构，更加轻量、高性能，支持跨平台，使用.NET Core运行时</li>
</ul>
</blockquote>
<h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><p>领域驱动设计是一种针对复杂需求的软件开发方法，它适用于复杂领域和大规模应用，关注核心领域逻辑而不是基础设施细节。</p>
<h3 id="基本分层"><a href="#基本分层" class="headerlink" title="基本分层"></a>基本分层</h3><p>DDD分层设计包含表现层(Presentation Layer)、应用层(Application Layer)、领域层(Domain Layer)、基础设施层(Infrastructure Layer)四个部分。</p>
<ul>
<li>表现层包含应用的UI组件，通过API网关连接前端应用和后端微服务</li>
<li>应用层用于协调表现层和领域层，不包含领域逻辑，只负责调用领域层的功能</li>
<li>领域层包含基本的业务对象，是独立的可重用的领域逻辑，不依赖于任何层</li>
<li>基础设施层提供数据持久化、消息传递和第三方集成等服务，包括数据库访问层、消息队列等</li>
</ul>
<p>领域层和应用层是业务逻辑的核心部分。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层包含应用服务、数据传输对象(DTO)、工作单元(UOW)等基本概念。</p>
<ul>
<li>数据传输对象用于表现层和应用层之间传输数据</li>
<li>工作单元是事务边界，其中的所有状态更改必须以原子方式实现</li>
</ul>
<h4 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h4><p>领域层包含实体(Entity)、值对象(Value Object)、聚合(Aggregate)和聚合根(AggregateRoot)、仓储(IRepository)、领域服务(Domain Service)、领域事件(Domain Event)等基本概念。</p>
<ul>
<li>值对象与实体不同之处在于，没有唯一标识符，如果两个值对象的所有属性都相同，则它们被认为是相同的(c# 9.0中record新特性与此类似)</li>
<li>聚合根通常是一个具有唯一标识(‌如GUID)的实体，‌它负责协调聚合内部的其他实体和值对象，‌确保数据的一致性和完整性</li>
<li>领域服务是实现核心业务规则的无状态服务(类命名通常以Manager为结尾)，它的实现依赖于多种聚合或外部服务</li>
</ul>
<h2 id="ABP框架"><a href="#ABP框架" class="headerlink" title="ABP框架"></a>ABP框架</h2><p>在使用ABP框架时，需要特别注意项目之间的引用和依赖关系。</p>
<h3 id="设计演变"><a href="#设计演变" class="headerlink" title="设计演变"></a>设计演变</h3><p>按照DDD的最初设计，ABP框架应当包含以下四个部分</p>
<ul>
<li>[company].[application].Web</li>
<li>[company].[application].Application</li>
<li>[company].[application].Domain</li>
<li>[company].[application].Infrastructure</li>
</ul>
<p>基础设施层通常需要包含一种对象关系映射(ORM)方式，ABP中使用了EntityFrameworkCore，<br>由此框架演变为</p>
<ul>
<li>[company].[application].Web</li>
<li>[company].[application].Application</li>
<li>[company].[application].Domain</li>
<li>[company].[application].EntityFrameworkCore</li>
</ul>
<p>由于Web层直接引用Application，而Application直接引用Domain，这将导致Application间接引用Domain，这不符合抽象和实现分层原则，因此ABP引入了Application.Contracts</p>
<ul>
<li>[company].[application].Web</li>
<li>[company].[application].Application.Contracts</li>
<li>[company].[application].Application</li>
<li>[company].[application].Domain</li>
<li>[company].[application].EntityFrameworkCore</li>
</ul>
<p>由于我们将接口定义和DTO存放在了Application.Contracts，而DTO有时需要重用Domain中的枚举类型，但Application.Contracts又无法直接添加对Domain的引用，为了解决这个问题，ABP引入了Domain.Shared</p>
<ul>
<li>[company].[application].Web</li>
<li>[company].[application].Application.Contracts</li>
<li>[company].[application].Application</li>
<li>[company].[application].Domain</li>
<li>[company].[application].Domain.Shared</li>
<li>[company].[application].EntityFrameworkCore</li>
</ul>
<p>为了将REST API与UI分离，ABP引入了HttpApi，此外还引入了HttpApi.Client客户端代理系统和数据库迁移工具DbMigrator，由此完整的项目框架为</p>
<ul>
<li>[company].[application].Web</li>
<li>[company].[application].HttpApi</li>
<li>[company].[application].HttpApi.Client</li>
<li>[company].[application].Application.Contracts</li>
<li>[company].[application].Application</li>
<li>[company].[application].Domain</li>
<li>[company].[application].Domain.Shared</li>
<li>[company].[application].EntityFrameworkCore</li>
<li>[company].[application].DbMigrator</li>
</ul>
<img src="/Hexo-Blog/2024/08/13/abp-and-ddd/abp_layer_deps.png" class="" title="ABP框架中各层之间的依赖关系">

<p>从上图可以看出，Domain层无法直接使用Application.Contracts中的DTO，必要时可使用Domain.Shared中的Value Object代替DTO。</p>
<p>此外，ABP框架中test文件夹中还包含了每一层单独配置的单元&#x2F;集成测试项目。</p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><h4 id="安装cli"><a href="#安装cli" class="headerlink" title="安装cli"></a>安装cli</h4><p>使用donet tool命令行工具下载abp-cli(第一代)</p>
<p><code>dotnet tool install -g Volo.Abp.Cli</code></p>
<p>查看是否安装成功</p>
<p><code>dotnet tool list -g</code></p>
<h4 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h4><p>EFCore提供了一套原生的数据库迁移系统，基于Code First原则。</p>
<p>在Domain层创建好相关实体后，将EntityFrameworkCore模块设为启动项目，打开Nuget Package Manager Console输入以下命令</p>
<p><code>Add-Migration &quot;Initial&quot;</code></p>
<p><code>Update-Database</code></p>
<p>最后将DbMigrator模块设为启动项后，运行即可完成种子数据迁移</p>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><h4 id="PGSQL时间类型问题"><a href="#PGSQL时间类型问题" class="headerlink" title="PGSQL时间类型问题"></a>PGSQL时间类型问题</h4><p><a href="https://github.com/abpframework/abp/issues/11437">PGSQL issues with 5.1.2 (and earlier, due to Npgsql 6+) #11437</a></p>
<blockquote>
<p>Cannot write DateTime with Kind&#x3D;Local to PostgreSQL type ‘timestamp with time zone’, only UTC is supported.</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// adding the below to the WebModule, DbMigratorModule and TestBaseModule </span></span><br><span class="line"><span class="comment">// if postgres is used there as well</span></span><br><span class="line">Configure&lt;AbpClockOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Kind = DateTimeKind.Utc;</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="Autofac依赖注入问题"><a href="#Autofac依赖注入问题" class="headerlink" title="Autofac依赖注入问题"></a>Autofac依赖注入问题</h4><blockquote>
<p>Autofac.Core.DependencyResolutionException:<br>An exception was thrown while activating xxxController -&gt; xxxAppService.<br>—&gt; Autofac.Core.DependencyResolutionException:<br>None of the constructors found on type ‘xxxAppService’ can be invoked with the available services and parameters:<br>Cannot resolve parameter<br>‘Microsoft.AspNetCore.Identity.SignInManager`1[Volo.Abp.Identity.IdentityUser] signInManager’ of constructor<br>‘Void .ctor(Microsoft.AspNetCore.Identity.SignInManager&#96;1[Volo.Abp.Identity.IdentityUser], …)’.</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add AbpIdentityAspNetCoreModule to your WebModule,</span></span><br><span class="line"><span class="comment">// be careful about the difference between Volo.Abp.Identity.AspNetCore and Microsoft.AspNetCore.Identity</span></span><br><span class="line">[<span class="meta">DependsOn(</span></span><br><span class="line"><span class="meta">    ...</span></span><br><span class="line"><span class="meta">    typeof(AbpIdentityAspNetCoreModule)</span></span><br><span class="line"><span class="meta">    )</span>]</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history#c-version-9">C# 9.0 新特性</a></li>
<li><a href="https://abp.io/docs/latest/">ABP官方文档</a></li>
<li><a href="https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=vs">EFCore数据库迁移</a></li>
</ul>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>ABP</tag>
        <tag>.NET</tag>
        <tag>ASP.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title>持续集成、交付与部署CI/CD及Jenkins</title>
    <url>/Hexo-Blog/2024/08/25/ci-and-cd/</url>
    <content><![CDATA[<p>持续集成、交付与部署CI&#x2F;CD基本概念、流程，以及使用Jenkins实现自动化部署。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CI&#x2F;CD是持续集成(Continuous Integration，CI)、持续交付(Continuous Delivery，CD)与持续部署(Continuous Deployment，CD)的简称。</p>
<p>CI&#x2F;CD是实现敏捷开发和Devops理念的一种方法，可让持续自动化和持续监控贯穿于应用的整个生命周期。这些关联的事务通常被统称为CI&#x2F;CD管道(Pipeline)，由开发(RD)、测试(QA)、运维(OP)团队以敏捷方式协同支持。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><img src="/Hexo-Blog/2024/08/25/ci-and-cd/ci_step.png" class="" title="持续集成流程图">

<p>持续集成(CI)指的是高频率地将代码合入主干，在合入之前触发单元测试去验证代码的改动，确保改动不会对应用造成破坏。</p>
<p>持续集成强调开发人员提交了新的代码后，立刻进行构建、(单元)测试。根据测试结果，我们可以确定新代码能否和原代码正确地集成在一起。</p>
<h3 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h3><img src="/Hexo-Blog/2024/08/25/ci-and-cd/cd_step.png" class="" title="持续交付流程图">

<p>持续交付(CD)指的是频繁地将软件的新版本，交付给质量团队或者用户、以供评审。如果评审通过，代码就会进入生产阶段。持续交付的目标是拥有一个可随时部署到生产环境的代码库。</p>
<p>持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的类生产环境中。比如完成单元测试后，可以将代码部署到连接数据库的Staging环境中进行更多的(集成)测试。如果代码没有问题，可以继续手动部署到生产环境中。</p>
<h3 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h3><img src="/Hexo-Blog/2024/08/25/ci-and-cd/cd_step_2.png" class="" title="持续部署流程图">

<p>持续部署(CD)是持续交付的下一步，指的是代码通过评审后，自动部署到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的自动化测试。</p>
<h2 id="CI-CD流程"><a href="#CI-CD流程" class="headerlink" title="CI&#x2F;CD流程"></a>CI&#x2F;CD流程</h2><p>根据CI&#x2F;CD的设计，代码从提交到生产，有以下几个步骤：</p>
<ul>
<li>提交：开发者向代码仓库提交一次代码</li>
<li>测试(第一轮)：代码仓库对commit操作配置了hook，只要提交了代码或者合并到主分支，就会跑自动化测试。测试的种类分为：<ul>
<li>单元测试(针对函数或模块的测试)</li>
<li>集成测试(针对产品的某个功能的测试)</li>
<li>端到端测试(从用户界面直达数据库的全链路测试)</li>
</ul>
</li>
<li>构建：将源码转换为可以运行的实际代码，如安装依赖、配置各种资源等。常用的构建工具有：<ul>
<li>Jenkins</li>
<li>Travis CI</li>
<li>GitLab CI&#x2F;CD</li>
</ul>
</li>
<li>测试(第二轮)：对第一轮测试的补充，可省略</li>
<li>部署：将可部署的版本中的所有文件打包到生产服务器上，生产服务器将打包文件解包成本地目录，再将运行路径符号链接指向这个目录，然后重新启动应用。</li>
<li>回滚：一但当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法是修改链接符号，指向上一个版本的目录</li>
</ul>
<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><p>Jenkins是一个开源的实现持续集成的工具。Jenkins能实时监控集成中的存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式展示项目构建的趋势和稳定性。</p>
<h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><p>使用Docker下载Jenkins镜像</p>
<p><code>docker pull jenkins/jekins:lts</code></p>
<p>创建目录并更改权限</p>
<p><code>mkdir -p /mydata/jenkins_home</code></p>
<p><code>chmod 777 /mydata/jenkins_home</code></p>
<p>运行Jenkins容器</p>
<p><code>docker run -di --name=jenkins -p [host-port]:[container-port] -v /mydata/jenkins_home/:/var/jenkins_home/ jenkins/jekins:lts</code></p>
<p>查看Jenkins运行是否成功</p>
<p><code>docker ps -a</code></p>
<h3 id="创建管理员用户"><a href="#创建管理员用户" class="headerlink" title="创建管理员用户"></a>创建管理员用户</h3><p>通过docker启动日志获取Jenkins控制台解锁密码</p>
<p><code>docker logs jenkins</code></p>
<p>输入解锁密码后填写信息创建一个管理员用户。</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>可通过Jenkins控制台的系统管理&gt;插件管理在线安装插件，也可到官网下载hpi插件文件然后上传使用。</p>
<h3 id="全局工具配置"><a href="#全局工具配置" class="headerlink" title="全局工具配置"></a>全局工具配置</h3><p>可通过Jenkins控制台的系统管理&gt;全局工具配置，配置JDK、Git、Maven等运行环境。</p>
<h3 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h3><ul>
<li>通过Jenkins控制台安装SSH插件</li>
<li>通过凭据&gt;全局添加服务器账号密码的凭据</li>
<li>通过系统管理&gt;系统配置，添加SSH remote hosts，主机名为服务器IP，端口默认22</li>
</ul>
<h3 id="创建自动构建任务"><a href="#创建自动构建任务" class="headerlink" title="创建自动构建任务"></a>创建自动构建任务</h3><p>可通过Jenkins控制台的新建任务&gt;构建一个自由风格的软件项目新建一个任务，在源码管理添加Git远程仓库(需要添加Git账号密码凭据)，构建环境选择Delete workspace before build starts，并增加构建步骤(添加执行shell，或添加使用SSH在远程服务器上执行脚本)。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">app_name=[jenkinsdemo]</span><br><span class="line"><span class="built_in">cd</span> /var/lib/jenkins/workspace/<span class="variable">$&#123;app_name&#125;</span>/[project_name]</span><br><span class="line">docker container prune &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">y</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">docker container <span class="built_in">ls</span> -a | grep <span class="string">&quot;<span class="variable">$&#123;app_name&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    docker container stop <span class="variable">$&#123;app_name&#125;</span></span><br><span class="line">    docker container <span class="built_in">rm</span> <span class="variable">$&#123;app_name&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">docker image prune &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">y</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">docker build -t <span class="variable">$&#123;app_name&#125;</span> .</span><br><span class="line">docker run -d --name=<span class="variable">$&#123;app_name&#125;</span> -p [host-port]:[container-port]  <span class="variable">$&#123;app_name&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://www.jenkins.io/zh/doc/">Jenkins官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>Devops</tag>
        <tag>Jenkins</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker虚拟化技术与容器化部署</title>
    <url>/Hexo-Blog/2024/08/15/docker-usage/</url>
    <content><![CDATA[<p>Docker基本概念、安装配置、容器化部署及常用命令。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker是一种操作系统层面的轻量级虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器(Container)。与虚拟机(VM)相比，Docker使用宿主机的操作系统，启动更快。每个容器只运行所需的应用程序和依赖项，资源消耗更少。Docker将操作系统、运行时环境、第三方软件库和依赖包、应用程序、环境变量、配置文件、启动命令等打包在一起，以便在任何环境中都能正常运行。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><img src="/Hexo-Blog/2024/08/15/docker-usage/docker_architecture.png" class="" title="Docker架构图">

<h3 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h3><p>Docker使用Client-Server架构，Docker Clinet和Docker Daemon之间通过Socket或Restful API进行通信。</p>
<p>Docker Daemon是服务端的守护进程，负责管理Docker的各种资源，接受并处理来自客户端的请求，然后将结果返回给客户端。</p>
<h3 id="Docker镜像与容器"><a href="#Docker镜像与容器" class="headerlink" title="Docker镜像与容器"></a>Docker镜像与容器</h3><p>镜像(Images)是一个只读的容器模板，含有启动Docker容器所需的文件系统结构及内容。容器是Docker的运行实例，它提供了一个独立的可移植的环境。Docker以镜像和在镜像基础上构建的容器为基础，以容器开发、测试、发布的单元将应用相关的所有组件和环境进行封装，避免了应用在不同平台间迁移所带来的依赖问题，确保了应用在生产环境的各阶段达到高度一致的实际效果。</p>
<h3 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h3><p>Docker仓库(Registry)是用来集中存储和管理Docker镜像的地方。常用的有Dockerhub，用户可在此分享和下载Docker镜像，以实现镜像的共享和复用。</p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>Docker官网在国内需要vpn才能访问，可通过国内镜像地址下载。Docker的使用可通过命令行方式，也可通过图形化工具Docker Desktop。</p>
<p>Windows系统中启动Docker Desktop的先决条件</p>
<ul>
<li>安装WSL</li>
<li>开启Hyper-V功能</li>
</ul>
<h2 id="容器化与Dockerfile"><a href="#容器化与Dockerfile" class="headerlink" title="容器化与Dockerfile"></a>容器化与Dockerfile</h2><p>Dockerfile是Docker用来构建镜像的指令文件，Docker容器化包含以下三个部分</p>
<ul>
<li><p>创建一个Dockerfile</p>
</li>
<li><p>使用Dockerfile构建镜像</p>
</li>
<li><p>使用镜像创建和构建容器</p>
</li>
</ul>
<p>例如要使用node在alpine中运行一个index.js文件，对应的Dockerfile为</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> index.js /index.js</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> node /index.js</span></span><br></pre></td></tr></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h4><p>拉取镜像</p>
<p><code>docker pull [image-url]</code></p>
<p>构建镜像</p>
<p><code>docker build -t [image-name] .</code></p>
<p>运行镜像</p>
<p><code>docker run [image-name] .</code></p>
<p>查看所有镜像</p>
<p><code>docker image ls</code></p>
<p><code>docker images</code></p>
<p>上传镜像</p>
<p><code>docker push [image-url]</code></p>
<p>删除镜像</p>
<p><code>docker rmi [image-name] /</code></p>
<p><code>docker image rm [image-name]</code></p>
<p>从容器创建镜像</p>
<p><code>docker commit [container-name] [image-name]</code></p>
<h4 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h4><p>创建容器</p>
<p><code>docker create [image-name]</code></p>
<p>启动运行并命名容器</p>
<p><code>docker run  --name [container-name] [image-name]</code></p>
<p>停止容器</p>
<p><code>docker stop [container-name]</code></p>
<p>删除容器</p>
<p><code>docker rm [container-name] /</code></p>
<p><code>docker container rm [container-name]</code></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a href="https://docs.docker.com/">Docker官方文档</a></p>
</li>
<li><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">如何使用WSL在Windows上安装Linux</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Virtualization-Technology</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/Hexo-Blog/2024/08/11/git-usage/</url>
    <content><![CDATA[<p>协作开发时一些常用的git命令。</p>
<span id="more"></span>

<h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>git变基到[branch]</p>
<p><code>git rebase [branch]</code></p>
<p>git变基后合并冲突</p>
<p><code>git rebase --cotinue</code></p>
<p>合并代码前先进行变基操作(避免多出一条和分支修改无关的commit)</p>
<p><code>git pull --rebase</code></p>
<p>git变基修改多次提交</p>
<p><code>git rebase -i [commit-id]</code> 或 <code>git rebase -i HEAD~n</code></p>
<p>git取消变基</p>
<p><code>git rebase --abort</code></p>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>git重置提交到[commit-id]，并强制推送</p>
<p><code>git reset --hard [commit-id]]</code></p>
<p><code>git push -f</code></p>
<h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><p>git回退到某一版本并提交</p>
<p><code>git revert [commit-id]</code></p>
<p><code>git commit -m [commit-id]</code></p>
<h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><p>git获取远程分支内容</p>
<p><code>git fetch -a  origin/[branch]</code></p>
<p>本地remote分支和远程同步</p>
<p><code>git remote prune origin</code></p>
<p>将本次修改的内容合并到上一次提交中，并强制推送</p>
<p><code>git commit -a --amend</code></p>
<p><code>git push -f</code></p>
<h2 id="Git-批处理"><a href="#Git-批处理" class="headerlink" title="Git 批处理"></a>Git 批处理</h2><h3 id="filter-branch"><a href="#filter-branch" class="headerlink" title="filter-branch"></a>filter-branch</h3><p>本地git中的用户名和邮箱配置错误，会导致远程仓库提交记录中无法正确显示作者信息(用户名、头像等)，还会导致用户贡献无法统计。</p>
<p>如果只是更正单条作者信息，使用rebase即可。</p>
<p><code>git rebase -i -p [commit-id]</code></p>
<p><code>git commit --amend --author=&quot;New Name Value &lt;correct@example.com&gt;&quot; --no-edit</code></p>
<p><code>git rebase --continue</code></p>
<p>若要重写所有历史commit中的授权用户和提交用户，可以使用<code>git filter-branch</code>编写批处理脚本，</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you see bash tips &quot;A previous backup already exists in refs/original/&quot;,</span></span><br><span class="line"><span class="comment"># that means you are not doing this for the first time.</span></span><br><span class="line"><span class="comment"># Just use &#x27;-f&#x27; to force to rewrite.</span></span><br><span class="line">git filter-branch --env-filter <span class="string">&#x27;</span></span><br><span class="line"><span class="string">WRONG_EMAIL=&quot;wrong@example.com&quot;</span></span><br><span class="line"><span class="string">NEW_NAME=&quot;New Name Value&quot;</span></span><br><span class="line"><span class="string">NEW_EMAIL=&quot;correct@example.com&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$WRONG_EMAIL&quot; ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">    export GIT_COMMITTER_NAME=&quot;$NEW_NAME&quot;</span></span><br><span class="line"><span class="string">    export GIT_COMMITTER_EMAIL=&quot;$NEW_EMAIL&quot;</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$WRONG_EMAIL&quot; ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">    export GIT_AUTHOR_NAME=&quot;$NEW_NAME&quot;</span></span><br><span class="line"><span class="string">    export GIT_AUTHOR_EMAIL=&quot;$NEW_EMAIL&quot;</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">&#x27;</span> --tag-name-filter <span class="built_in">cat</span> -- --branches --tags</span><br></pre></td></tr></table></figure>

<p>在git仓库根目录下运行后，使用<code>git push -f</code>强制推送即可。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://git-scm.com/docs/git/zh_HANS-CN">Git官方中文文档</a></p>
]]></content>
      <categories>
        <category>Version-Control</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法在JWT、SSH中的应用</title>
    <url>/Hexo-Blog/2024/08/27/jwt-and-ssh/</url>
    <content><![CDATA[<p>对称加密、非对称加密算法在不同场景中的应用，如使用JWT进行单点登录、使用SSH进行远程免密登录等。</p>
<span id="more"></span>


<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密是一种加密和解密所使用的密钥是相同的加密算法。在对称加密中，发送方和接收方使用相同的密钥对数据进行加密和解密。常见的对称加密算法包括DES、3DES、AES等。</p>
<p>对称加密的优势在于速度快，加解密过程简单，适合用于传输大量数据。但是对称加密无法提供身份验证和数据完整性保护，即无法判断消息的发送方是否可信以及数据是否被篡改。</p>
<p>对称加密通常与其他的加密技术(如数字签名、消息认证码等)结合使用，以提供更高的安全性保护。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密是一种加密算法，与对称加密不同，非对称加密使用一对不同的密钥来进行加密和解密。这对密钥中的一个被称为私钥(private key)，另一个被称为公钥(public key)。私钥只能由密钥的拥有者持有并保密，不对外公开，而公钥可以向任何人公开。常见的非对称加密算法包括RSA、ECC等。</p>
<p>在非对称加密中，加密和解密过程如下：</p>
<ol>
<li>发送方使用接收方的公钥对明文进行加密，生成密文</li>
<li>接收方使用自己的私钥对密文进行解密，恢复为明文</li>
</ol>
<p>非对称加密算法的特点是安全性高，能够提供身份验证和数据完整性保护。但是非对称加密的缺点是速度较慢，加解密过程相对复杂，适合处理少量的数据。</p>
<p>因此，通常会将对称加密和非对称加密相结合，在传输数据时使用非对称加密来交换对称加密所需的密钥，然后使用对称加密算法来加密和解密实际的数据。</p>
<h2 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h2><p>消息认证码(Message Authentication Code, 简称MAC)是一种确认完整性并进行认证的技术。</p>
<p>消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥，它可以输出固定长度的数据，这个数据称为MAC值。要计算MAC值必须持有共享密钥，消息认证码正是利用这一性质来完成身份认证的。此外，消息认证码通过类似单向散列函数的散列值来确保数据完整性。</p>
<p>HMAC是一种使用单向散列函数来构造消息认证码的方法。HMAC中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于HMAC，如果将来设计出新的单向散列函数，也同样可以使用。使用SHA-256、MD5、RIPEMD-160所构造的HMAC，分别称为HMAC-SHA-256、HMAC-MD5和HMAC-RlPEMD。</p>
<p>消息认证码中，由于发送者和接收者共享相同的密钥，因此会产生无法对第三方证明以及无法防止否认等问题。</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名(又称公钥数字签名)是只有信息的发送者才能产生的别人无法伪造的一段数字串。数字签名中也同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和非对称加密是相反的，即用私钥加密相当于生成签名，而用公钥解密则相当于验证签名。通常情况下，为了提高传输效率，不会直接对原始数据进行数字签名，而是对原始数据的Hash值进行签名。</p>
<p>数字签名的过程如下：</p>
<ol>
<li><p>生成签名：</p>
<ul>
<li><p>对原始数据进行哈希运算(使用预先约定的哈希算法)，得到Hash值</p>
</li>
<li><p>使用非对称加密的私钥对Hash值加密，得到签名</p>
</li>
<li><p>发送原始数据及签名</p>
</li>
</ul>
</li>
<li><p>验证签名：</p>
<ul>
<li><p>接收原始数据及签名</p>
</li>
<li><p>对数字签名使用公钥解密, 得到Hash值</p>
</li>
<li><p>对原始数据进行哈希运算得到新的Hash值，如果两者一致，则签名验证成功；如果两者不一致，则签名验证失败</p>
</li>
</ul>
</li>
</ol>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT(JSON Web Token)是目前最流行的跨域身份验证解决方案，适用于身份鉴权、授权、信息交换、单点登录等场景。JWT可以使用密钥(使用HMAC算法)或使用RSA或ECDSA的公钥&#x2F;私钥对进行签名。</p>
<p>应用程序获取JWT并用于访问API等资源的过程如下：</p>
<ol>
<li>客户端向授权服务器请求授权</li>
<li>授权服务器校验用户身份，如果校验成功，返回访问令牌(token)</li>
<li>应用程序使用访问令牌访问受保护的资源，服务端通过验证JWT的签名来确认用户的身份，通过解析JWT中的声明信息判断用户是否有权限执行特定的操作或访问特定的资源</li>
</ol>
<p>JWT由Header、Payload、Signature三部分组成：</p>
<ul>
<li><p>JWT的头部通常由两部分组成，分别是令牌类型(typ)和加密算法(alg)。一般情况下，头部会采用Base64编码。</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>JWT的载荷也称为声明信息(claims)，包含了一些有关实体(通常是用户)的信息以及其他元数据。通常包含预定义的字段，如iss(发行者)、sub(主题)、aud(受众)、exp(过期时间)、nbf(生效时间)、iat(发布时间)和jti(JWT ID)等，以及自定义字段。</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5a3cd526-caa4-4952-a5ba-f44245fe1762&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1681102951</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nbf&quot;</span><span class="punctuation">:</span> <span class="number">1681102951</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1681189351</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jocoboy&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WebUser&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JWT的签名是由头部、载荷和密钥(通常为32个字节)共同生成的，用于验证JWT的真实性和完整性。使用Header里面指定的签名算法(默认是HMAC-SHA256)，按照下面的公式产生签名</p>
  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">base64UrlEncode(payload),</span><br><span class="line">secret)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>.NET使用HMAC-SHA256对称加密算法生成JWT的部分代码如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> key = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(_authOptions.Secret));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> credentials = <span class="keyword">new</span> SigningCredentials(key, SecurityAlgorithms.HmacSha256);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> token = <span class="keyword">new</span> JwtSecurityToken(_authOptions.Issuer,</span><br><span class="line">    _authOptions.Audience,</span><br><span class="line">    claims,</span><br><span class="line">    DateTime.Now,</span><br><span class="line">    DateTime.Now.AddMinutes(_authOptions.Expiration),</span><br><span class="line">    credentials);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(token);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>安全外壳协议(Secure Shell, 简称SSH)是一种建立在应用层基础上，在不安全网络上用于安全远程登录和其他安全网络服务的协议。</p>
<p>SSH建立在非对称加密之上，建立远程连接的过程如下：</p>
<ol>
<li>远程主机(虚拟机)收到本地主机的登录请求，把自己的公钥发给本地主机</li>
<li>本地主机使用这个公钥，将登录密码加密后，发送给远程主机</li>
<li>远程主机用自己的私钥，解密登录密码，如果密码正确，则同意本地主机登录</li>
</ol>
<h3 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h3><p>Linux系统中以用户名username，登录远程主机remote_host的命令如下</p>
<p><code>ssh username@remote_host</code></p>
<p>初次连接会提示公钥指纹，确认指纹无误后输入密码，远程主机的公钥就会自动保存到本地主机的.ssh&#x2F;known_hosts文件中。</p>
<h3 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h3><p>公钥登录可以省去输入密码的步骤。用户将自己的公钥储存在远程主机上，登录时远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录。</p>
<p>在本地主机生成一对公钥和私钥，然后将公钥添加到远程主机的 ~&#x2F;.ssh&#x2F;authorized_keys文件中(Windows系统中把.ssh&#x2F;id_rsa.pub的内容复制出来，手动追加即可)</p>
<p><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></p>
<p><code>ssh-copy-id username@remote_host</code></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a href="https://jwt.io/introduction">JWT官方文档</a></p>
</li>
<li><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Generating new SSH key</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Cyber-Security</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes核心组件与集群搭建</title>
    <url>/Hexo-Blog/2024/08/17/kubernetes-usage/</url>
    <content><![CDATA[<p>kubernetes的核心组件、架构体系、环境搭建(minikube&#x2F;k3s)，以及kubectl常用命令和可视化管理工具Portainer。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>kubernetes是一个全新的基于容器技术的分布式架构领先方案。kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><img src="/Hexo-Blog/2024/08/17/kubernetes-usage/kubernetes_components.png" class="" title="kubernetes部分核心组件">

<ul>
<li>node，一个物理机或虚拟机</li>
<li>pod，一个或多个应用容器的组合(如sidecar模式，应用容器与辅助容器共用一个Pod)。pod之间可通过内部ip地址访问</li>
<li>svc(service)，将一组pod封装为一个服务，可以通过一个统一的入口来访问，相当于反向代理，可以解决因pod销毁导致的内部ip地址变更问题</li>
<li>node:port，端口节点，提供内部服务对外的IP映射</li>
<li>ing(ingress)，用来管理从集群外部访问集群内部服务的入口和方式，可以配置不同的转发规则，根据不同的规则访问不同的svc，以及svc对应的pod。此外还可以配置域名、负载均衡、SSL证书等</li>
<li>cm(config map)，用来存储应用程序配置信息，实现应用程序与配置信息的解耦</li>
<li>secret，为cm中的敏感信息提供Base64加密，需要配合其他安全机制(如网络控制、访问控制、身份认证)一起使用</li>
<li>vol(volume)，可以将应用数据挂载到集群内部的本地磁盘上，或是集群外部的远程存储上，实现数据的持久化</li>
<li>deploy(deployment)，定义和管理应用程序的副本数量，是pod上的一层抽象</li>
<li>replicaset，介于pod与deploy之间，用于管理pod</li>
<li>sts(stateful set)，和deploy类似，用来管理有状态的应用(如数据库、缓存、消息队列等)</li>
</ul>
<h2 id="Master-Worker架构"><a href="#Master-Worker架构" class="headerlink" title="Master-Worker架构"></a>Master-Worker架构</h2><p>kubernetes是典型的Master-Worker架构。Master-Node负责管理整个集群，Worker-Node负责运行应用程序和服务。</p>
<img src="/Hexo-Blog/2024/08/17/kubernetes-usage/kubernetes_architecture.png" class="" title="kubernetes架构图">

<ul>
<li>kubelet，负责管理和维护每个node上的pod</li>
<li>kube-proxy，负责提供网络代理和负载均衡服务</li>
<li>container-runtime，负责提供容器运行时(如docker engine)</li>
<li>kube-apiserver，负责提供API接口服务</li>
<li>etcd，高可用的键值存储系统，负责存储集群中各种资源对象的状态信息</li>
<li>c-m(controller manager)，负责管理集群中各种资源对象的状态</li>
<li>sched(schedular)，负责监控集群中所有节点的资源使用情况，然后根据一些调度策略，将pod调度到合适的node上运行</li>
<li>c-c-m(cloud controller manager)，云平台控制器，负责与云平台的api交互</li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="minikube"><a href="#minikube" class="headerlink" title="minikube"></a>minikube</h3><p>minukube是一个轻量级的kubernetes实现，可在本地计算机上创建虚拟机，并部署仅包含一个节点的简单集群。</p>
<p>kubectl是一个命令行工具，可以通过在命令行输入各种命令与MasterNode的kube-apiserver交互，从而与Kubernetes集群进行交互。</p>
<p>在windows中使用chocolatey安装minukube</p>
<p><code>choco install minkube</code></p>
<p>查看版本信息验证是否安装成功</p>
<p><code>minikube version</code></p>
<p>创建集群(选择国内镜像源并指定版本)</p>
<p><code>minikube start --image-mirror-country=&#39;cn&#39;  --kubernetes-version=v1.23.9</code></p>
<p>查看集群中的节点信息</p>
<p><code>kubectl get nodes</code></p>
<p>Docker Desktop也自带了minukube，可手动开启。</p>
<h3 id="k3s"><a href="#k3s" class="headerlink" title="k3s"></a>k3s</h3><p>k3s是一个CNCF认证的轻量级的kubernetes发行版，可以方便地搭建一个多节点集群。</p>
<h4 id="准备虚拟机环境"><a href="#准备虚拟机环境" class="headerlink" title="准备虚拟机环境"></a>准备虚拟机环境</h4><p>在windows中使用chocolatey安装multipass</p>
<p><code>choco install multipass</code></p>
<p>创建一个名为k3s的虚拟机</p>
<p><code>multipass launch --name k3s</code></p>
<p>启动虚拟机</p>
<p><code>multipass start k3s</code></p>
<p>登录到虚拟机</p>
<p><code>multipass shell k3s</code></p>
<p>通过multipass创建的虚拟机默认不允许SSH远程登录，需要额外配置。</p>
<ul>
<li>添加用户密码 <code>sudo passwd ubuntu</code></li>
<li>修改SSH配置 <code>sudo vi /etc/ssh/sshd_config</code>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PubkeyAuthentication yes</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">KbdInteractiveAuthentication yes    </span><br></pre></td></tr></table></figure></li>
<li>重启SSH服务 <code>sudo service ssh restart</code></li>
<li>使用SSH登录 <code>ssh ubuntu@ip</code></li>
</ul>
<h4 id="创建和配置Master节点"><a href="#创建和配置Master节点" class="headerlink" title="创建和配置Master节点"></a>创建和配置Master节点</h4><p>使用国内镜像安装k3s</p>
<p><code>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -</code></p>
<p>查看当前节点(Master节点)</p>
<p><code>sudo kubectl get nodes</code></p>
<h4 id="创建和配置Worker节点"><a href="#创建和配置Worker节点" class="headerlink" title="创建和配置Worker节点"></a>创建和配置Worker节点</h4><p>在Master节点上获取token，作为其它节点加入集群的凭证</p>
<p><code>sudo cat /var/lib/rancher/k3s/server/node-token</code></p>
<p>将TOKEN保存到环境变量</p>
<p><code>TOKEN=$(multipass exec k3s sudo cat /var/lib/rancher/k3s/server/node-token)</code></p>
<p>保存master节点的IP地址</p>
<p><code>MASTER_IP=$(multipass info k3s | grep IPv4 | awk &#39;&#123;print $2&#125;&#39;)</code></p>
<p>使用刚刚的TOKEN和MASTER_IP来创建两个worker节点，并把它们加入到集群中</p>
<ul>
<li><p>创建两个worker节点的虚拟机</p>
<p>  <code>multipass launch --name worker1 --cpus 2 --memory 8G --disk 10G</code></p>
<p>  <code>multipass launch --name worker2 --cpus 2 --memory 8G --disk 10G</code></p>
</li>
<li><p>在worker节点虚拟机上安装k3s</p>
<p>  <code>for f in 1 2; do   multipass exec worker$f -- bash -c &quot;curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn K3S_URL=\&quot;https://$MASTER_IP:6443\&quot; K3S_TOKEN=\&quot;$TOKEN\&quot; sh -&quot;   done</code></p>
</li>
</ul>
<h3 id="在线环境"><a href="#在线环境" class="headerlink" title="在线环境"></a>在线环境</h3><p>k8s也可通过在线环境使用</p>
<ul>
<li><p><a href="https://labs.play-with-k8s.com/">labs.play-with-k8s</a></p>
</li>
<li><p><a href="https://killercoda.com/">killercoda</a></p>
</li>
</ul>
<h2 id="kubectl常用命令"><a href="#kubectl常用命令" class="headerlink" title="kubectl常用命令"></a>kubectl常用命令</h2><p>创建一个pod</p>
<p><code>sudo kubectl run [pod-name] --image=[image-name]</code></p>
<p>创建一个deployment，指定镜像为nginx</p>
<p><code>sudo kubectl create deployment [deployment-name] --image=[image-name]</code></p>
<p>通过配置文件创建一个deployment</p>
<p><code>vi [deployment-name].yaml</code></p>
<p><code>sudo kubectl create -f [deployment-name].yaml</code></p>
<p>修改deployment</p>
<p><code>sudo kubectl edit deployment [deployment-name]</code></p>
<p>通过配置文件修改deployment</p>
<p><code>sudo kubectl apply -f [deployment-name].yaml</code></p>
<p>删除deployment</p>
<p><code>sudo kubectl delete deployment [deployment-name]</code></p>
<p>通过配置文件删除deployment</p>
<p><code>sudo kubectl delete -f [deployment-name].yaml</code></p>
<p>查看pod或deployment</p>
<p><code>sudo kubectl get pod</code></p>
<p><code>sudo kubectl get deployment</code></p>
<p>查看pod日志</p>
<p><code>sudo kubectl logs [pod-name]</code></p>
<p>将deployment对外公开为service</p>
<p><code>sudo kubectl expose deployment [deployment-name]</code></p>
<p>查看服务详细信息</p>
<p><code>sudo kubectl describe service [deployment-name]</code></p>
<p>删除服务</p>
<p><code>sudo kubectl delete service [deployment-name]</code></p>
<p>通过配置文件创建NodePort类型的服务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># 使用的Kubernetes API版本，这里是v1。</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  <span class="comment"># 定义资源类型为Service，表示创建一个服务。</span></span><br><span class="line"><span class="attr">metadata:</span>  <span class="comment"># 元数据部分，用于描述Service的基本信息。</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span>  <span class="comment"># Service的名称为nginx-service。</span></span><br><span class="line"><span class="attr">spec:</span>  <span class="comment"># 规格部分，定义Service的规格。</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>	<span class="comment"># 指定服务类型，默认为ClusterIP</span></span><br><span class="line">  <span class="attr">selector:</span>  <span class="comment"># 选择器部分，用于指定服务应该选择哪些Pod作为后端。</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>  <span class="comment"># 选择具有标签app=nginx的Pod作为后端。</span></span><br><span class="line">  <span class="attr">ports:</span>  <span class="comment"># 端口配置，定义Service暴露的端口。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span>  <span class="comment"># 使用TCP协议。</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span>  <span class="comment"># Service暴露的端口号为80。</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span>  <span class="comment"># 转发到后端Pod的端口号也为80。</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span></span><br></pre></td></tr></table></figure>

<p><code>sudo kubectl apply -f [service-name].yaml</code></p>
<p>查看当前集群命名空间</p>
<p><code>sudo kubectl ns</code></p>
<h2 id="可视化管理工具Portainer"><a href="#可视化管理工具Portainer" class="headerlink" title="可视化管理工具Portainer"></a>可视化管理工具Portainer</h2><p>安装portainer，并将其暴露在NodePort&#x3D;30777上</p>
<p><code>kubectl apply -n portainer -f https://downloads.portainer.io/ce2-19/portainer.yaml</code></p>
<p>在集群外部输入ip地址+端口号即可访问。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a href="https://kubernetes.io/docs/home/">kubernetes官方文档</a></p>
</li>
<li><p><a href="https://minikube.sigs.k8s.io/docs/">minukube官方文档</a></p>
</li>
<li><p><a href="https://multipass.run/docs/multipass-cli-client">multipass官方文档-常用命令</a></p>
</li>
<li><p><a href="https://docs.rancher.cn/docs/k3s/quick-start/_index/">k3s官方文档-快速入门</a></p>
</li>
<li><p><a href="https://docs.portainer.io/">Portainer官方文档</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/Hexo-Blog/2024/08/16/linux-usage/</url>
    <content><![CDATA[<p>Linux系统基本概念、安装配置、各级目录含义、常用命令，以及VIM编辑器常用命令。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux系统相比于Windows而言，开源，运行更稳定和安全。Linux系统是一个多层次的结构，包含了内核、系统库、shell以及应用程序。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h3><p>Linux发行版是Linux内核与软件包、系统工具、库文件等组成的一个完整的操作系统，它提供了一个预先配置好的Linux环境，使我们能更方便的安装、配置、使用Linux系统。常见的发型版有Redhat、CentOS、Ubuntu、Alpine等。</p>
<h2 id="安装配置Linux"><a href="#安装配置Linux" class="headerlink" title="安装配置Linux"></a>安装配置Linux</h2><p>Linux系统可通过虚拟机软件(如VMWare&#x2F;VirtualBox&#x2F;Multipass)、容器(如Docker)安装，也可通过云服务器(如AWS&#x2F;Azure&#x2F;阿里云)直接使用。</p>
<p>Windows系统中推荐先<a href="(https://cn.ubuntu.com/download)">下载Unbuntu镜像文件</a>，然后通过VMWare安装Unbuntu。</p>
<h2 id="VI-VIM常用命令"><a href="#VI-VIM常用命令" class="headerlink" title="VI&#x2F;VIM常用命令"></a>VI&#x2F;VIM常用命令</h2><p>Linux系统中没有图形化编辑器，通常在服务器环境上需要借助VIM快速编辑修改文件配置。</p>
<p>VI是Unix操作系统和类Unix操作系统中最通用的文本编辑器。VIM编辑器是从VI发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM与VI编辑器完全兼容。</p>
<p>VIM包含一般模式、编辑模式、命令模式等，相应的语法详见VIM使用参考手册。</p>
<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>按照修改时间逆序显示文件的详细信息</p>
<p><code>ls -ltr</code></p>
<p>查看文件内容</p>
<p><code>cat [file]</code></p>
<p>创建文件并写入文件内容</p>
<p><code>echo [content] &gt; [file]</code></p>
<p>创建硬链接文件(源文件删除不影响目标文件)</p>
<p><code>ln [target_file] [source_file]</code></p>
<p>创建软链接文件(源文件删除会影响目标文件)</p>
<p><code>ln  -s [target_file] [source_file]</code></p>
<p>删除文件</p>
<p><code>rm [file]</code></p>
<p>以索引方式删除文件(乱码文件)</p>
<p><code>ls -i</code></p>
<p><code>find -inum [index] -delete</code></p>
<p>复制文件</p>
<p><code>cp [source_file] [target_file]</code></p>
<p>重命名文件</p>
<p><code>mv [source_file] [target_file]</code></p>
<p>给文件添加权限</p>
<p><code>chmod [u/g/o]+[w/r/x] [file]</code></p>
<p>给文件添加最高权限</p>
<p><code>chmod 777 [file]</code></p>
<h3 id="目录和文件夹"><a href="#目录和文件夹" class="headerlink" title="目录和文件夹"></a>目录和文件夹</h3><p>Linux系统中各级目录含义如下图所示。</p>
<img src="/Hexo-Blog/2024/08/16/linux-usage/linux_dir.png" class="" title="Linux系统中各目录含义">

<p>查看当前目录</p>
<p><code>pwd</code></p>
<p>切换到根目录</p>
<p><code>cd /</code></p>
<p>创建目录</p>
<p><code>mkdir [dir]</code></p>
<p>创建多级目录</p>
<p><code>mkdir -p [dir1]/[dir2]/..</code></p>
<p>复制目录</p>
<p><code>cp -r [source_dir] [target_dir]</code></p>
<p>查看目录结构(文件大小)</p>
<p><code>du</code> </p>
<p><code>sudo apt install tree</code></p>
<p><code>tree</code></p>
<p>删除目录</p>
<p><code>rm -r [dir]</code></p>
<h3 id="dotnet程序包更新"><a href="#dotnet程序包更新" class="headerlink" title="dotnet程序包更新"></a>dotnet程序包更新</h3><p>切换到root用户</p>
<p><code>sudo su -</code></p>
<p>列出系统中所有进程的详细信息</p>
<p><code>ps -ef | grep dotnet</code></p>
<p>关闭进程</p>
<p><code>sudo kill -9 [pid]</code></p>
<p>查找进程文件夹</p>
<p><code>ll /proc/[pid]</code></p>
<p>进入进程文件夹并覆盖式上传程序包</p>
<p><code>cd /opt/vhosts/...</code></p>
<p><code>rz -y</code></p>
<p>解压程序包</p>
<p><code>unzip -o [*.zip]</code></p>
<p>启动程序</p>
<p><code>nohup dotnet [app].Web.dll --urls=http://localhost:[port] &amp;</code></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a href="https://vimcdoc.sourceforge.net/doc/editing.html">VIM使用参考手册</a></p>
</li>
<li><p><a href="https://info-ee.surrey.ac.uk/Teaching/Unix/index.html">Linux Tutorial for Beginners</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Operation-System</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx反向代理与负载均衡</title>
    <url>/Hexo-Blog/2024/08/16/nginx-usage/</url>
    <content><![CDATA[<p>Nginx常用命令，反向代理与负载均衡实现方法，以及HTTPS配置。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是高性能的HTTP和反向代理的web服务器，处理高并发能力是十分强大，能支持高达50,000个并发连接数。Nginx支持热部署，启动简单，可以做到7*24不间断运行，几个月都不需要重新启动。Nginx适用于各种场景，包括静态文件服务、反向代理、负载均衡等。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="正向-反向代理"><a href="#正向-反向代理" class="headerlink" title="正向&#x2F;反向代理"></a>正向&#x2F;反向代理</h3><p>正向代理代理的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过何种方式访问的。</p>
<img src="/Hexo-Blog/2024/08/16/nginx-usage/forward_proxy.png" class="" title="正向代理架构图">

<p>反向代理代理的是服务端，客户端对代理是无感知的，客户端不需要任何配置就可以访问。我们只需要把请求发送给反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器的地址。</p>
<img src="/Hexo-Blog/2024/08/16/nginx-usage/reverse_proxy.png" class="" title="反向代理架构图">

<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡是指增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上。</p>
<p>Nignx提供了三种负载均衡的方式：轮询法(默认)、加权轮询、ip_hash。</p>
<p>这三种负载均衡方式可以组合使用，例如搭建三个服务器并完成反向代理，对应的配置文件如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 127.0.0.1:8000 weight=3;</span><br><span class="line">        server 127.0.0.1:8001;</span><br><span class="line">        server 127.0.0.1:8002;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    server&#123;</span><br><span class="line">        ...</span><br><span class="line">        location /app &#123;</span><br><span class="line">            proxy_pass http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>Nignx可通过包管理器、C语言编译、docker等方式安装。</p>
<p>Linux平台下，使用包管理器安装</p>
<p><code>sudo apt update</code></p>
<p><code>sudo apt install nginx</code></p>
<p>使用docker安装</p>
<p><code>dcoker pull nginx</code></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>启动nginx</p>
<p><code>nginx</code></p>
<p>查看nginx进程</p>
<p><code>ps -ef|grep nginx</code></p>
<p>查看nginx端口占用情况</p>
<p><code>lsof -i:[port]</code></p>
<p>停止nginx</p>
<p><code>nginx -s stop</code> 或 <code>nginx -s quit</code></p>
<p>重载配置文件</p>
<p><code>nginx reload</code></p>
<p>重新打开配置文件</p>
<p><code>nginx reopen</code></p>
<p>查看安装目录、编译参数、日志文件及配置文件位置</p>
<p><code>nginx -V</code></p>
<p>查看nginx配置文件</p>
<p><code>nginx -t</code></p>
<p>静态文件部署</p>
<p><code>cp -rf * [path]</code></p>
<h2 id="HTTPS配置"><a href="#HTTPS配置" class="headerlink" title="HTTPS配置"></a>HTTPS配置</h2><p>HTTPS协议需要使用SSL证书，在主流的云平台上都可以申请到免费的SSL证书，也可以通过openssl命令生成一个自签名的证书(未经过CA认证)。</p>
<h3 id="使用openssl生成证书"><a href="#使用openssl生成证书" class="headerlink" title="使用openssl生成证书"></a>使用openssl生成证书</h3><p>生成私钥文件(private key)</p>
<p><code>openssl genrsa -out private.key 2048</code></p>
<p>根据私钥生成证书签名请求文件(csr文件)</p>
<p><code>openssl req -new -key private.key -out cert.csr</code></p>
<p>使用私钥对证书申请进行签名从而生成证书文件(pem文件)</p>
<p><code>openssl x509 -req -in cert.csr -out cacert.pem -signkey private.key</code></p>
<h3 id="修改nginx配置"><a href="#修改nginx配置" class="headerlink" title="修改nginx配置"></a>修改nginx配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    server&#123;</span><br><span class="line">        listen   443 ssl;</span><br><span class="line">        server_name         localhost;</span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line">        ssl_certificate     www.example.com.crt;</span><br><span class="line">        ssl_certificate_key www.example.com.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class="line">        ssl_ciphers         HIGH:!aNULL:!MD5;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://nginx.org/en/docs/">Nignx官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Web-Server</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>基于PGSQL咨询锁函数实现的分布式锁</title>
    <url>/Hexo-Blog/2024/08/30/pgsql-distributed-lock/</url>
    <content><![CDATA[<p>基于PGSQL咨询锁函数实现的一个分布式锁基础设施。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PostgreSQL提供了分布式锁服务，可以用于多个数据库实例(会话)之间协调访问资源。通过使用pg_advisory_lock等咨询锁函数，可以实现一个由应用定义其含义的分布式锁基础设施。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p>锁的一种宏观分类方式是悲观锁和乐观锁。乐观锁和悲观锁是并发控制的一种机制，用于多线程或多进程环境下对共享资源的访问管理，以防止数据不一致或竞态条件。悲观锁与乐观锁并不是特指某个锁，而是在并发情况下的两种不同策略。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁是一种对资源持有较悲观态度的锁定方式。它假设数据在并发访问时极有可能发生冲突，因此每次访问数据时都会先加锁，以确保其他线程不能访问此数据直到锁被释放。</p>
<p>悲观锁常见的实现方式是数据库中的行级锁、表级锁或行级锁等。一旦线程获得锁，其它尝试获取锁的线程都会被阻塞，直到锁被释放。</p>
<ul>
<li>适用场景：在高并发、数据竞争激烈的场景中使用，如金融交易、库存管理等。</li>
<li>缺点：<ul>
<li>可能导致系统吞吐量降低，因为锁定机制会阻止其他线程并发访问资源</li>
<li>容易产生死锁，如果锁的持有和释放管理不当，会导致系统无法继续运行</li>
</ul>
</li>
</ul>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁则持相对乐观的态度，假设并发操作冲突的可能性较小，因此不会主动加锁，而是进行数据版本检查来决定是否提交操作。</p>
<p>乐观锁一般通过版本号或时间戳等机制来实现。在数据读取时，获取当前版本号；在数据更新时，检查版本号是否与之前读取时的一致。如果一致，表示没有其他并发操作修改过数据，可以提交；否则，操作失败回滚。 </p>
<ul>
<li>适用场景：适用于读操作多、写操作少的场景，如一些阅读类应用、CMS系统等。因为这些场景下，冲突发生的概率较低，乐观锁可以提高系统的并发性。</li>
<li>缺点：<ul>
<li>在并发冲突频繁的场景下，可能会导致大量重试操作，影响性能</li>
<li>需要开发人员显式管理版本控制机制，增加开发复杂度</li>
</ul>
</li>
</ul>
<h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>比较并替换(Compare-and-Swap)是乐观锁实现的基础。CAS操作包括三个步骤：读取内存值、比较内存值与预期值、如果相等则更新内存值。CAS锁可以有效地解决传统锁机制中的性能问题和死锁问题，是并发编程中常用的同步手段之一。</p>
<h3 id="线程锁、进程锁与分布式锁"><a href="#线程锁、进程锁与分布式锁" class="headerlink" title="线程锁、进程锁与分布式锁"></a>线程锁、进程锁与分布式锁</h3><h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>线程锁也被称为互斥锁(Mutex)，主要用于控制同一进程中的多个线程对共享资源的访问。</p>
<p>在C#中，可以使用lock关键字来实现互斥锁。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object lockObject = <span class="keyword">new</span> Object();</span><br><span class="line">...</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 在需要保护共享资源的代码块中使用lock</span></span><br><span class="line">    <span class="keyword">lock</span> (lockObject)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">// 访问和修改共享资源的代码</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="进程锁"><a href="#进程锁" class="headerlink" title="进程锁"></a>进程锁</h4><p>进程锁是用于控制同一台机器上的多个进程对共享资源的访问。进程锁可以是系统级的，如文件锁；也可以是用户级的，如信号量。</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>分布式锁是用于控制分布式系统中的多个节点对共享资源的访问。由于分布式系统中的节点可能位于不同的物理机甚至不同的地理位置，因此分布式锁的实现比线程锁和进程锁要复杂得多。分布式锁需要在网络中的多个节点之间进行协调，以保证锁的唯一性和一致性。</p>
<h3 id="PGSQL咨询锁"><a href="#PGSQL咨询锁" class="headerlink" title="PGSQL咨询锁"></a>PGSQL咨询锁</h3><p>PostgreSQL提供了一种由应用定义其含义的锁，这种锁被称为咨询锁(Advisory Lock)。咨询锁是一种悲观锁、分布式锁。咨询锁用一个long类型的数值或两个int类型的数值标识一把锁，long类型标识的锁和int类型标识的锁互相独立。</p>
<p>咨询锁有两个锁定级别：会话级和事务级。</p>
<ul>
<li>会话级锁定会持续到显式释放或会话结束，不受会话中事务的影响</li>
<li>事务级锁定不能显式释放，会持续锁定到事务结束</li>
</ul>
<p>不论哪个级别的锁定都是可重入的，即同一个线程在持有锁的情况下，可以多次获取该锁而不会造成死锁。</p>
<p>咨询锁有两种锁定模式：独占和共享。</p>
<ul>
<li>独占锁定和其它的独占锁定或共享锁定都互斥</li>
<li>共享锁定只和独占锁定互斥, 共享锁定之间不互斥</li>
</ul>
<p>锁定模式不受锁定级别影响，同一把锁的会话级独占锁定和事务级独占锁定会正确的互斥。</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>PGSQL一共提供了21个咨询锁函数，抛开标识类型不谈，lock和unlock分别代表获取锁定和释放锁定。以_shared结尾的代表锁定是共享的而非独占的，带_xact_关键字代表锁定级别是事务级而非会话级的，带_try_关键字代表锁定是不可等待的。</p>
<h5 id="定义锁定模式"><a href="#定义锁定模式" class="headerlink" title="定义锁定模式"></a>定义锁定模式</h5><p>定义一个枚举作为区分锁定模式的参数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 锁定模式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> LockMode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 独占</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Exclusive = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 共享</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Shared = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定义咨询锁接口"><a href="#定义咨询锁接口" class="headerlink" title="定义咨询锁接口"></a>定义咨询锁接口</h5><p>会话级锁继承IDisposable接口，以便数据库连接等资源的释放。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISessionLock</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义不同标识类型、不同会话级别下的咨询锁接口。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAdvisoryLock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对long类型的数值标识的锁进行会话级别的锁定</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">Task&lt;ISessionLock&gt; <span class="title">LockAsync</span>(<span class="params"><span class="built_in">long</span> k, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对由两个int类型的数值标识的锁进行会话级别的锁定</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">Task&lt;ISessionLock&gt; <span class="title">LockAsync</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对long类型的数值标识的锁进行事务级别的锁定</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">Task&lt;<span class="built_in">bool</span>&gt; <span class="title">XactLockAsync</span>(<span class="params"><span class="built_in">long</span> k, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对由两个int类型的数值标识的锁进行事务级别的锁定</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">Task&lt;<span class="built_in">bool</span>&gt; <span class="title">XactLockAsync</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现会话级锁的显示释放"><a href="#实现会话级锁的显示释放" class="headerlink" title="实现会话级锁的显示释放"></a>实现会话级锁的显示释放</h5><p>由于会话级锁定会持续到显式释放或会话结束，需要实现显示释放。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PGSQLSessionLock</span> : <span class="title">ISessionLock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> DatabaseFacade database;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">long</span>? kid;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>? mid;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>? nid;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isShare;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposedValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PGSQLSessionLock</span>(<span class="params">DatabaseFacade database, <span class="built_in">long</span> kid, <span class="built_in">bool</span> isShare</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.database = database;</span><br><span class="line">        <span class="keyword">this</span>.kid = kid;</span><br><span class="line">        <span class="keyword">this</span>.isShare = isShare;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PGSQLSessionLock</span>(<span class="params">DatabaseFacade database, <span class="built_in">int</span> mid, <span class="built_in">int</span> nid, <span class="built_in">bool</span> isShare</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.database = database;</span><br><span class="line">        <span class="keyword">this</span>.mid = mid;</span><br><span class="line">        <span class="keyword">this</span>.nid = nid;</span><br><span class="line">        <span class="keyword">this</span>.isShare = isShare;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReleaseLock</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShare)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kid != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                database.ExecuteSqlRaw(<span class="string">&quot;select pg_advisory_unlock_shared(&#123;0&#125;)&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; kid.Value &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                database.ExecuteSqlRaw(<span class="string">&quot;select pg_advisory_unlock_shared(&#123;0&#125;,&#123;1&#125;)&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; mid.Value, nid.Value &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kid != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                database.ExecuteSqlRaw(<span class="string">&quot;select pg_advisory_unlock(&#123;0&#125;)&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; kid.Value &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                database.ExecuteSqlRaw(<span class="string">&quot;select pg_advisory_unlock(&#123;0&#125;,&#123;1&#125;)&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; mid.Value, nid.Value &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposedValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ReleaseLock();</span><br><span class="line">            database = <span class="literal">null</span>;</span><br><span class="line">            disposedValue = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~PGSQLSessionLock()</span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(disposing: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(disposing: <span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现咨询锁"><a href="#实现咨询锁" class="headerlink" title="实现咨询锁"></a>实现咨询锁</h5><p>实现不同锁定标识、不同锁定级别下的咨询锁函数，每个咨询锁函数定义了锁定标识、锁定模式、是否可等待参数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PGSQLAdvisoryLock</span> : <span class="title">IAdvisoryLock</span>, <span class="title">ISingletonDependency</span></span><br><span class="line">&#123;</span><br><span class="line">    IDbContextProvider&lt;ABPDemoDbContext&gt; _dbContextProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PGSQLAdvisoryLock</span>(<span class="params">IDbContextProvider&lt;ABPDemoDbContext&gt; dbContextProvider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _dbContextProvider = dbContextProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ISessionLock&gt; <span class="title">LockAsync</span>(<span class="params"><span class="built_in">long</span> k, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> database = (<span class="keyword">await</span> _dbContextProvider.GetDbContextAsync()).Database;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> locked = <span class="keyword">await</span> InternalLockAsync(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; k &#125;, lockMode, waiting, <span class="literal">false</span>, database, cancellationToken);</span><br><span class="line"></span><br><span class="line">        ISessionLock result = locked ? <span class="keyword">new</span> PGSQLSessionLock(database, k, lockMode == LockMode.Shared) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ISessionLock&gt; <span class="title">LockAsync</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> database = (<span class="keyword">await</span> _dbContextProvider.GetDbContextAsync()).Database;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> locked = <span class="keyword">await</span> InternalLockAsync(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; m, n &#125;, lockMode, waiting, <span class="literal">false</span>, database, cancellationToken);</span><br><span class="line"></span><br><span class="line">        ISessionLock result = locked ? <span class="keyword">new</span> PGSQLSessionLock(database, m, n, lockMode == LockMode.Shared) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">XactLockAsync</span>(<span class="params"><span class="built_in">long</span> k, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> database = (<span class="keyword">await</span> _dbContextProvider.GetDbContextAsync()).Database;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> InternalLockAsync(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; k &#125;, lockMode, waiting, <span class="literal">true</span>, database, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">XactLockAsync</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> database = (<span class="keyword">await</span> _dbContextProvider.GetDbContextAsync()).Database;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> InternalLockAsync(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; m, n &#125;, lockMode, waiting, <span class="literal">true</span>, database, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">InternalLockAsync</span>(<span class="params"><span class="built_in">object</span>[] parameters, LockMode lockMode, <span class="built_in">bool</span> waiting, <span class="built_in">bool</span> isXact, DatabaseFacade database, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> locked;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> xact = isXact ? <span class="string">&quot;_xact&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> param = parameters.Length == <span class="number">1</span> ? <span class="string">&quot;&#123;0&#125;&quot;</span> : <span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> mode = lockMode <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            LockMode.Exclusive =&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">            LockMode.Shared =&gt; <span class="string">&quot;_shared&quot;</span>,</span><br><span class="line">            _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">$&quot;LockMode.<span class="subst">&#123;lockMode&#125;</span> is not implemented.&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waiting)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> database.ExecuteSqlRawAsync(<span class="string">$&quot;select pg_advisory<span class="subst">&#123;xact&#125;</span>_lock<span class="subst">&#123;mode&#125;</span>(<span class="subst">&#123;param&#125;</span>)&quot;</span>, parameters);</span><br><span class="line"></span><br><span class="line">            locked = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            locked = (<span class="keyword">await</span> database.SqlQueryRaw&lt;<span class="built_in">bool</span>&gt;(<span class="string">$&quot;select pg_try_advisory<span class="subst">&#123;xact&#125;</span>_lock<span class="subst">&#123;mode&#125;</span>(<span class="subst">&#123;param&#125;</span>)&quot;</span>, parameters).ToListAsync()).Single();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locked;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用方式"><a href="#应用方式" class="headerlink" title="应用方式"></a>应用方式</h4><h5 id="在应用中定义和使用"><a href="#在应用中定义和使用" class="headerlink" title="在应用中定义和使用"></a>在应用中定义和使用</h5><p>首先定义一个锁枚举，具体名称由应用的功能派生，比如定义一个更新学生信息的锁StudentUpdate。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Locks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">long</span> StudentUpdate = <span class="number">10001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后置于并发操作上下文(替换操作之前)即可。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IAdvisoryLock _advisoryLock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StudentAppService</span>(<span class="params">..., IAdvisoryLock advisoryLock</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">    _advisoryLock = advisoryLock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">await</span> _studentRepository.GetAsync(x =&gt; x.Name == input.Name, <span class="literal">false</span>, cancellationToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> _advisoryLock.LockAsync(Locks.StudentUpdate, LockMode.Exclusive, <span class="literal">true</span>, cancellationToken);</span><br><span class="line"></span><br><span class="line">student.Name = input.Name;</span><br><span class="line">student.StudentLevel = input.StudentLevel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> _studentRepository.UpdateAsync(student, <span class="literal">false</span>, cancellationToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ObjectMapper.Map&lt;Student,StudentDto&gt;(student);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="验证锁是否生效"><a href="#验证锁是否生效" class="headerlink" title="验证锁是否生效"></a>验证锁是否生效</h5><p>在LockAsync之后打上断点，调用API命中断点之后，使用SQL语句查看锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_locks t1</span><br><span class="line"><span class="keyword">JOIN</span>  pg_stat_activity t2</span><br><span class="line"><span class="keyword">ON</span> t1.pid  <span class="operator">=</span> t2.pid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.pid;</span><br></pre></td></tr></table></figure>

<img src="/Hexo-Blog/2024/08/30/pgsql-distributed-lock/pgsql_pg_lock.png" class="" title="命中断点后数据库锁的情况">

<p>使用SQL语句再次获取该锁定标识对应的锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_advisory_lock(<span class="number">10001</span>);</span><br></pre></td></tr></table></figure>

<img src="/Hexo-Blog/2024/08/30/pgsql-distributed-lock/pgsql_pg_lock_waiting.png" class="" title="获取该锁定标识对应的锁">

<p>可以看到该锁定标识对应的资源已被阻塞，将等待直到该资源变成可用。点击继续跳过断点之后即可再次成功获取。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://www.postgres.cn/docs/12/functions-admin.html#FUNCTIONS-ADVISORY-LOCKS">PGSQL中文文档-咨询锁函数</a></li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>PostgreSQL</tag>
        <tag>Concurrency Control</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL常用SQL语句</title>
    <url>/Hexo-Blog/2024/08/12/pgsql-usage/</url>
    <content><![CDATA[<p>PostgreSQL数据库中的一些常用SQL。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PostgreSQL相较于MySQL而言，具有更强的事务处理能力，能够处理更复杂的数据操作和高并发访问。同时其提供了更丰富的索引类型，能够进行更细粒度的查询和优化。此外还支持多种数据类型和函数库，可以处理更复杂的应用程序。</p>
<h2 id="PGSQL常用语句"><a href="#PGSQL常用语句" class="headerlink" title="PGSQL常用语句"></a>PGSQL常用语句</h2><h3 id="扩展安装"><a href="#扩展安装" class="headerlink" title="扩展安装"></a>扩展安装</h3><p>安装uuid生成函数扩展</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;uuid-ossp&quot;;</span><br></pre></td></tr></table></figure>


<p>注: []标注的内容必须带双引号””</p>
<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>获取uuid</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> uuid_generate_v4();</span><br></pre></td></tr></table></figure>

<p>获取东八时(北京时间)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> now() <span class="keyword">AT</span> <span class="type">TIME</span> ZONE (<span class="string">&#x27;CCT&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>类型转换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--写法一</span></span><br><span class="line"><span class="keyword">SELECT</span> t.&quot;Id&quot;::<span class="type">varchar</span>;</span><br><span class="line"><span class="comment">--写法二</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">cast</span>(t.&quot;Id&quot; <span class="keyword">AS</span> <span class="type">varchar</span>);</span><br></pre></td></tr></table></figure>


<h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.[table_name] </span><br><span class="line">([column_name], ...) </span><br><span class="line"><span class="keyword">VALUES</span>(column_value, ...);</span><br></pre></td></tr></table></figure>

<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> public.[table_name]  </span><br><span class="line"><span class="keyword">SET</span> [column_name]  <span class="operator">=</span> column_value</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<h4 id="FOR-UPDATE-行级锁"><a href="#FOR-UPDATE-行级锁" class="headerlink" title="FOR UPDATE(行级锁)"></a>FOR UPDATE(行级锁)</h4><p>更新表时跳过被锁定的行</p>
<p>注: <code>[column_a_id]</code>代表外键列，依赖于表a</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> public.[table_b]    </span><br><span class="line"><span class="keyword">SET</span> [column_3]  <span class="operator">=</span> column_value</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line">        	<span class="keyword">SELECT</span> b.<span class="operator">*</span>, a.[column_1]</span><br><span class="line">        	<span class="keyword">FROM</span> [table_b] b</span><br><span class="line">        	<span class="keyword">JOIN</span> [table_a] a <span class="keyword">ON</span> b.[column_a_id] <span class="operator">=</span> a.&quot;Id&quot;</span><br><span class="line">        	<span class="keyword">WHERE</span> ...</span><br><span class="line">        	<span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> </span><br><span class="line">        	(</span><br><span class="line">        		<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">        		<span class="keyword">FROM</span> [table_b] b2</span><br><span class="line">        		<span class="keyword">WHERE</span> b2.[column_a_id] <span class="operator">=</span> b.[column_a_id] </span><br><span class="line">                <span class="keyword">AND</span> b2.[column_3] <span class="operator">=</span> column_value</span><br><span class="line">        	) </span><br><span class="line">        	<span class="keyword">ORDER</span> <span class="keyword">BY</span> a.[column_2]</span><br><span class="line">        	LIMIT <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">OF</span> b <span class="keyword">SKIP</span> LOCKED</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">where</span>  t.&quot;Id&quot; <span class="operator">=</span> b.&quot;Id&quot;  </span><br><span class="line">returning t.[column_1]</span><br></pre></td></tr></table></figure>

<h3 id="TRUNCATE-DROP-DELETE"><a href="#TRUNCATE-DROP-DELETE" class="headerlink" title="TRUNCATE&#x2F;DROP&#x2F;DELETE"></a>TRUNCATE&#x2F;DROP&#x2F;DELETE</h3><p>TRUNCATE常用于清理数据，可重置自增键，不破坏表结构，但无法回滚也无法携带WHERE语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> [table_name] CASCADE</span><br></pre></td></tr></table></figure>

<p>DROP会删除表结构及其依赖的索引、外键约束，无法回滚</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [table_name]</span><br></pre></td></tr></table></figure>

<p>DELETE可以携带WHERE语句，可以回滚，但不会重置自增键也不会释放表或索引占用的空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [table_name]</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<h3 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h3><p>更新表字段排序规则</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [table_name]  <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> [column_name] </span><br><span class="line"><span class="keyword">SET</span> DATA TYPE CHARACHTER VARING(<span class="number">50</span>) <span class="keyword">COLLATE</span> &quot;zh-x-icu&quot;</span><br></pre></td></tr></table></figure>


<h3 id="LEFT-JOIN-视图"><a href="#LEFT-JOIN-视图" class="headerlink" title="LEFT JOIN(视图)"></a>LEFT JOIN(视图)</h3><p>注: <code>[column_a_id]</code>代表外键列，依赖于表a；<code>[column_c_id]</code>代表外键列，依赖于表c</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> public.[view_name] </span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> </span><br><span class="line">	a.[column_name],</span><br><span class="line">    ...</span><br><span class="line">    c.[column_name],</span><br><span class="line">    ...</span><br><span class="line">    t.[column_name],</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">FROM</span> [table_a] a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ( </span><br><span class="line">    		<span class="keyword">SELECT</span> </span><br><span class="line">    		b.[column_name],</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">FROM</span> [table_b] b</span><br><span class="line">		  ) t </span><br><span class="line"><span class="keyword">ON</span> a.&quot;Id&quot; <span class="operator">=</span> t.[column_a_id]</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> [table_c] c</span><br><span class="line"><span class="keyword">ON</span> a.[column_c_id] <span class="operator">=</span> c.&quot;Id&quot;</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p>c#中LINQ写法，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> l <span class="keyword">in</span> leftSet</span><br><span class="line"><span class="keyword">join</span> r <span class="keyword">in</span> rightSet <span class="keyword">on</span> l.Id <span class="keyword">equals</span> r.Id <span class="keyword">into</span> groupJoin</span><br><span class="line"><span class="keyword">from</span> r <span class="keyword">in</span> groupJoin.DefaultIfEmpty() </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">new</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="函数与存储过程"><a href="#函数与存储过程" class="headerlink" title="函数与存储过程"></a>函数与存储过程</h3><h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4><p>生成uuid</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> public.uuid_generate_v4()</span><br><span class="line"><span class="keyword">RETURNS</span> uuid <span class="keyword">LANGUAGE</span> c</span><br><span class="line">PARALLEL SAFE STRICT</span><br><span class="line"><span class="keyword">AS</span> <span class="string">&#x27;$libdir/uuid-ossp&#x27;</span>, </span><br><span class="line">$<span class="keyword">function</span>$uuid_generate_v4$<span class="keyword">function</span>$;</span><br></pre></td></tr></table></figure>


<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> public.[procedure_name](<span class="keyword">IN</span> column_1_variable column_1_type) <span class="keyword">LANGUAGE</span> plpgsql</span><br><span class="line"><span class="keyword">AS</span> $<span class="keyword">procedure</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"></span><br><span class="line">	<span class="keyword">UPDATE</span> [table_a]  a</span><br><span class="line">	<span class="keyword">SET</span> [column_2] <span class="operator">=</span> column_value,</span><br><span class="line">	<span class="keyword">WHERE</span> a.[column_1] <span class="operator">=</span> column_variable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line">$<span class="keyword">procedure</span>$;</span><br></pre></td></tr></table></figure>

<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>创建自增序列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SEQUENCE task_id_seq</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> <span class="number">1</span></span><br><span class="line">INCREMENT <span class="keyword">BY</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">NO</span> MINVALUE</span><br><span class="line"><span class="keyword">NO</span> MAXVALUE</span><br><span class="line">CACHE <span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<h3 id="窗口函数和聚合函数"><a href="#窗口函数和聚合函数" class="headerlink" title="窗口函数和聚合函数"></a>窗口函数和聚合函数</h3><p>在PostgreSQL中，窗口函数（Window Functions）是对一组行进行计算的函数，比如求和、平均、排名等。它们可以用于创建复杂的分析查询，并且可以对一系列的行而不仅仅是组内的行进行操作。</p>
<p>聚合函数（Aggregate Functions）则是用于合并多个值，返回单一的值的函数，如COUNT、SUM、AVG、MIN、MAX等。</p>
<p>例如，分组计算平均值，窗口函数可以带出额外信息<code>[column_1]</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    [column_1],</span><br><span class="line">    [column_2],</span><br><span class="line">    <span class="built_in">AVG</span>([column_2]) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> [column_3]) <span class="keyword">AS</span> avg_value</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    [table_a]    </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    [column_2] <span class="operator">&gt;</span> avg_value;</span><br></pre></td></tr></table></figure>

<p>而聚合函数只能操作组内成员</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    [column_3]</span><br><span class="line">    <span class="built_in">AVG</span>([column_2]) <span class="keyword">AS</span> avg_value</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    [table_a]   </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    [column_3]</span><br></pre></td></tr></table></figure>

<p>组合用法，计算组内排名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    [column_1],</span><br><span class="line">    [column_2],</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> [column_3] <span class="keyword">ORDER</span> <span class="keyword">BY</span> [column_2] <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    [table_a] </span><br></pre></td></tr></table></figure>

<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>PGSQL数据库事务的隔离级别有以下四种:</p>
<ul>
<li>读未提交(READ UNCOMMITTED)</li>
<li>读已提交(READ COMMITTED)</li>
<li>重复读(REPEATABLE READ)</li>
<li>串行化(SERIALIZABLE)</li>
</ul>
<p>对于并发事务，我们不希望发生的行为如下：</p>
<ul>
<li>脏读：一个事务读取了另一个未提交的事务写入的数据</li>
<li>重复读：一个事务重新读取前面读取过的数据时，发现该数据已改变</li>
<li>幻读：当某个事务在读取某个范围内的记录时，另外一个事务中又在该范围插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行</li>
</ul>
<p>对于不同事务隔离级别，脏读、重复读、幻读的可能性如下</p>
<table>
<thead>
<tr>
<th>ISOLATION LEVEL</th>
<th>脏读</th>
<th>重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ABP中配置数据库事务隔离级别为读已提交</span></span><br><span class="line">...</span><br><span class="line">Configure&lt;AbpUnitOfWorkOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.IsolationLevel = IsolationLevel.ReadCommitted;</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="进程与会话"><a href="#进程与会话" class="headerlink" title="进程与会话"></a>进程与会话</h3><p>查看进程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_locks t1</span><br><span class="line"><span class="keyword">JOIN</span>  pg_stat_activity t2</span><br><span class="line"><span class="keyword">ON</span> t1.pid  <span class="operator">=</span> t2.pid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.pid;</span><br></pre></td></tr></table></figure>

<p>关闭进程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_terminate_backend(PID);</span><br></pre></td></tr></table></figure>

<p>查看会话</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_stat_activity <span class="keyword">WHERE</span> datname <span class="operator">=</span> <span class="string">&#x27;your_database&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>关闭当前会话</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DISCARD <span class="keyword">ALL</span>;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.postgresql.org/docs/">PGSQL官方文档</a></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ核心概念及应用场景</title>
    <url>/Hexo-Blog/2024/08/17/rabbitmq-usage/</url>
    <content><![CDATA[<p>RabbitMQ基本概念、安装配置、使用场景、消息模型，以及消息持久化、签收机制、延迟队列的实现。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RabbitMQ是基于AMQP(Advanced Message Queue Protocol)协议实现的消息队列，是一种应用程序之间的通信方法，在分布式系统开发中应用广泛。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><img src="/Hexo-Blog/2024/08/17/rabbitmq-usage/rabbitmq_architecture.png" class="" title="RabbitMQ工作原理">

<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>Broker是消息队列进程，包含Exchange、Queue两个部分。</p>
<h4 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h4><p>Exchange指消费队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过滤。</p>
<p>常用类型有direct、topic、fanout、headers四种。</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue指消息队列，消息打达队列后转发给指定的消费方。</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>Producer指消息生产者，生产者发布消息的过程如下：</p>
<ul>
<li><p>生产者和broker建立Connection，并开启一个channel</p>
</li>
<li><p>生产者声明一个交换机并设置相关属性(交换机类型、是否持久化)</p>
</li>
<li><p>生产者声明一个队列并设置相关属性(是否排他、是否持久化、是否自动删除)</p>
</li>
<li><p>生产者通过routing key将交换机和队列绑定</p>
</li>
<li><p>生产者通过channel发送给broker，由交换机根据接收到的routing key匹配队列</p>
</li>
<li><p>如果找到匹配的队列则存入，否则丢弃或回传</p>
</li>
</ul>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer指消息消费者，消费者接受消息的过程如下：</p>
<ul>
<li><p>消费者和broker建立Connection，并开启一个channel</p>
</li>
<li><p>消费者监听指定的队列，根据需要设置回调函数</p>
</li>
<li><p>当有消息到达队列时broker将消息推送给消费者</p>
</li>
<li><p>消费者确认接受到消息</p>
</li>
<li><p>broker删除队列中已经确认的消息</p>
</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>RabbitMQ通常有如下应用场景：</p>
<ul>
<li>高并发场景消除峰值，让并发请求在MQ中排队</li>
<li>大数据处理，将数据放入MQ，多开几个消费者处理(如日志收集)</li>
<li>服务异步和解耦，使用MQ进行异步通信后，服务之间没有直接的调用关系，生产方通过MQ与消费方通信，将应用程序进行解耦</li>
<li>FIFO排序，保证数据按顺序消费</li>
</ul>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>Windows系统中RabbitMQ可通过安装包下载(需要Erlang环境)，安装目录下启动图形化界面并重启服务</p>
<p><code>rabbitmq-plugins enable rabbitmq_management</code></p>
<p><code>rabbitmq-server stop</code></p>
<p><code>rabbitmq-server start</code></p>
<p>也可通过Dokcer下载镜像</p>
<p><code>docker pull rabbitmq:3-management</code></p>
<p>下载完成后启动容器(5672是程序连接的端口，15672是可视化界面接口)</p>
<p><code>docker run -id --name=rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3-management</code></p>
<h2 id="消息模型与交换机类型"><a href="#消息模型与交换机类型" class="headerlink" title="消息模型与交换机类型"></a>消息模型与交换机类型</h2><p>RabbitMQ包含以下5种消息模型</p>
<ul>
<li><p>Hello World简单模型，只需一个生产者、一个队列、一个消费者</p>
</li>
<li><p>Work Queue工作队列模型，多个消费者绑定到一个队列，共同消费队列中的消息，同一个消息只会被一个消费者消费。可使用prefetch防止某个消费者消费能力偏弱导致后续的消息阻塞</p>
</li>
<li><p>Publish&#x2F;Subscribe发布订阅模型(type&#x3D;fanout)，允许一个消息向多个消费者投递</p>
</li>
<li><p>Routing路由模型(type&#x3D;direct)，不同的消息可被不同的队列消费，通过一个routing key来收发消息</p>
</li>
<li><p>Topic通配符模型(type&#x3D;topic)，一种特殊的路由模式，在绑定队列时routing key可以使用通配符</p>
</li>
</ul>
<p>注: headers类型的路由不是用routing Key进行路由匹配，而是在匹配请求头中所带的键值进行路由</p>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>MQ消息在内存中进行读写，如果MQ宕机那么消息就要丢失的风险，我们需要可以通过交换机持久化、队列持久化等来防止消息丢失。</p>
<h2 id="签收机制"><a href="#签收机制" class="headerlink" title="签收机制"></a>签收机制</h2><p>RabbitMQ包含手动签收和自动签收2钟模式。</p>
<p>自动签收指MQ把消息投递给消费者后，消息默认被签收，MQ就会直接把消息删除掉。这种模式可能会导致消息丢失分享。</p>
<p>手动签收指MQ不会自动签收消息，而是把消息推送给消费者后，等到消费者自己去签收消息后，再删除队列中的消息，这种模式可以防止消息丢失。</p>
<h2 id="延迟队列和死信消息"><a href="#延迟队列和死信消息" class="headerlink" title="延迟队列和死信消息"></a>延迟队列和死信消息</h2><p>RabbitMQ可以给队列设置过期时间，也可以单独给每个消息设置过期时间，如果到了过期时间消息没被消费该消息就会标记为死信消息。根据这一特点，我们可以准备一个队列来接收死信交换机中的死信消息，然后准备一个消费者来消费该队列中的消息，这就是延迟队列。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://www.rabbitmq.com/docs">RabbitMQ官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库常用CLI命令</title>
    <url>/Hexo-Blog/2024/08/14/redis-usage/</url>
    <content><![CDATA[<p>Redis数据库的使用场景、使用方法、重要概念，以及一些常用的CLI命令。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis(Remote Dictionary Server)是一个高性能的(key&#x2F;value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，常用于数据缓存、充当消息队列等。Redis不仅仅支持简单的key-value类型的数据(如string)，同时还提供list，set，sorted set，hash等数据结构的存储。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>Redis在Mac&#x2F;Linux系统下可通过命令行直接安装，而在Windows系统下需要通过WSL安装一个Linux系统来安装Redis，或者通过Docker下载Redis镜像通过镜像运行Redis，也可以使用传统EXE安装包安装(不推荐)。Redis可通过CLI、API、GUI(如RedisInsight)三种方式使用。</p>
<h3 id="启动Redis服务"><a href="#启动Redis服务" class="headerlink" title="启动Redis服务"></a>启动Redis服务</h3><p>启动Redis</p>
<p><code>redis-server</code></p>
<p>报错</p>
<blockquote>
<p>Could not create server TCP listening socket *:6379: bind: 在一个非套接字上尝试了一个操作 。</p>
</blockquote>
<p>Redis安装目录下，依次输入</p>
<p><code>redis-cli.exe</code></p>
<p><code>shutdown</code></p>
<p><code>exit</code></p>
<p><code>redis-server.exe redis.windows.conf</code></p>
<h3 id="CLI常用命令"><a href="#CLI常用命令" class="headerlink" title="CLI常用命令"></a>CLI常用命令</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="key-value"><a href="#key-value" class="headerlink" title="key-value"></a>key-value</h5><p>设置键值对</p>
<p><code>SET [key] [value]</code></p>
<p>获取键值</p>
<p><code>GET [key]</code></p>
<p>删除键值对</p>
<p><code>DELETE [key]</code></p>
<p>判断键值对是否存在</p>
<p><code>EXISTS [key]</code></p>
<p>获取所有键值对</p>
<p><code>KEYS *</code></p>
<p>获取所有以xx结尾的键值对</p>
<p><code>KEYS *xx</code></p>
<p>删除所有键值对</p>
<p><code>FLUSHALL</code></p>
<p>设置键值对过期时间</p>
<p><code>EXPIRE [key] [seconds]</code></p>
<p>获取键值对过期时间</p>
<p><code>TTL [key]</code></p>
<p>设置键值对并设置过期时间</p>
<p><code>SETEX [key] [seconds] [value]</code></p>
<p>设置不存在的键值对(若已存在则忽略执行)</p>
<p><code>SETNX [key] [value]</code></p>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>创建列表并添加元素</p>
<p><code>LPUSH [list] [value, ...]</code></p>
<p><code>RPUSH [list] [value, ...]</code></p>
<p>获取整个列表</p>
<p><code>LRANGE [list] 0 -1</code></p>
<p>删除列表元素</p>
<p><code>LPOP [list] [count]</code></p>
<p><code>RPOP [list] [count]</code></p>
<p>获取列表长度</p>
<p><code>LLEN [list]</code></p>
<p>仅保留索引为n到m的部分列表</p>
<p><code>LTRIME [list] n m</code></p>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>创建集合并添加元素</p>
<p><code>SADD [set] [value, ...]</code></p>
<p>获取集合中的元素</p>
<p><code>SMEMBERS [set]</code></p>
<p>判断元素是否在集合中</p>
<p><code>SISMEMBER [set] [value]</code></p>
<p>删除集合中的元素</p>
<p><code>SREM [set] [value]</code></p>
<h5 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h5><p>创建有序集合并添加元素</p>
<p><code>ZADD [sortedset] [(score value), ...]</code></p>
<p>获取有序集合全部元素</p>
<p><code>ZRANGE [sortedset] 0 -1 WITHSCORES</code></p>
<p>获取有序集合某个元素权值</p>
<p><code>ZSCORE [sortedset] [value]</code></p>
<p>获取有序集合某个元素排名</p>
<p><code>ZRANK [sortedset] [value]</code></p>
<p><code>ZREVRANK [sortedset] [value]</code></p>
<p>删除有序集合某个元素</p>
<p><code>ZREM [sortedset] [value]</code></p>
<h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p>创建哈希集合</p>
<p><code>HSET [hash] [key] [value]</code></p>
<p>获取哈希集合中的元素</p>
<p><code>HGET [hash] [key]</code></p>
<p>获取哈希集合中的全部元素</p>
<p><code>HGETALL [hash]</code></p>
<p>删除哈希集合中的某个元素</p>
<p><code>HDEL [hash] [key]</code></p>
<p>判断哈希集合中的某个元素是否存在</p>
<p><code>HEXISTS [hash] [key]</code></p>
<p>获取哈希集合中的键</p>
<p><code>HKEYS [hash]</code></p>
<p>获取哈希集合长度</p>
<p><code>HLEN [hash]</code></p>
<h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><p>订阅频道</p>
<p><code>SUBSCRIBE [channel]</code></p>
<p>发布频道消息</p>
<p><code>PUBLISH [channel] [message]</code></p>
<h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><p>向消息队列中添加一条消息</p>
<p><code>XADD [stream] * [key] [value]</code></p>
<p>获取消息队列中消息数量</p>
<p><code>XLEN [stream]</code></p>
<p>获取消息队列中的所有消息</p>
<p><code>XRANGE [stream] - +</code></p>
<p>删除消息队列中的某条消息</p>
<p><code>XDEL [stream] [id]</code></p>
<p>删除消息队列中的所有消息</p>
<p><code>XTRIM [stream] MAXLEN 0</code></p>
<p>读取消息队列中索引为i开始的n条消息，如不存在阻塞x秒</p>
<p><code>XRED COUNT n BLOCK x STREAMS [stream] i</code></p>
<p>创建消费者组</p>
<p><code>XGROUP CREATE [stream] [group] [id]</code></p>
<p>获取消费者组信息</p>
<p><code>XINFO GROUPS [stream]</code></p>
<p>向消费者组中添加消费者</p>
<p><code>XGROUP CREATECONSUMER [stream] [group] [consumer]</code></p>
<p>读取消费者组中某消费者的最新n条消息，如不存在阻塞x秒</p>
<p><code>XREDGROUP [group] [consumer] COUNT n BLOCK x STREAMS [stream] &gt;</code></p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>注: Redis中的事务概念与传统事务概念不同，不保证原子性</p>
<p>标记一个事务开始</p>
<p><code>MULTI</code></p>
<p>提交事务</p>
<p><code>EXEC</code></p>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>Redis有RDB(Redis Database)和AOF(Append Only File)两种数据持久化方式。</p>
<h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><p>RDB相当于数据快照，可在redis.confg文件中配置自动触发，例如<u>save 60 10000</u>代表60s内如果有10000次修改则触发一次快照，也可通过CLI中的save命令手动触发。</p>
<h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><p>AOF相当于使用日志记录操作命令，可在redis.confg文件中配置参数<u>appendonly yes</u>自动触发。</p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>Redis主从复制是指将Redis主节点数据复制到从节点，数据的复制是单向的。</p>
<p>假设主节点端口号为6379，从节点端口号为6380。在从节点的redis.confg文件中配置参数<u>replicaof 127.0.0.1 6379</u>启用主从复制功能。启动从节点6380服务后，使用CLI命令</p>
<p><code>redis-cli -p 6380</code></p>
<p><code>info replication</code></p>
<p>即可看到当前节点角色已从master变为slave。</p>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>Redis主从复制存在一个问题，如果主节点宕机了，需要手动去将从节点设置为主节点。为了实现主节点的自动故障转移，Redis引入了一个独立的进程来监视主节点，通过发布订阅模式通知从节点变更为主节点。</p>
<p>创建配置文件sentinel.conf并配置参数<u>sentinel monitor master 127.0.0.1 6379 1</u>(1代表故障转移需要同意的哨兵的个数)，使用CLI命令</p>
<p><code>redis-sentinel sentinel.conf</code></p>
<p>即可启动哨兵进程。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://redis.io/docs/latest/commands/">Redis CLI命令官方文档</a></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Service远程调用技术</title>
    <url>/Hexo-Blog/2024/08/18/web-service-and-rpc/</url>
    <content><![CDATA[<p>Web Service远程调用技术(RPC)的基本概念及实现方式。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web Service即web服务，是一种跨编程语言和跨操作系统平台的远程调用技术。Web服务包含了一套标准,例如HTTP、XML、SOAP、WSDL、UDDI等，定义了应用程序如何在Web上实现互操作，可以在任何支持这些标准的平台（如Windows、Linux）中使用。</p>
<p>Web Service与Web API相比，更加适合端到端的应用场景(C&#x2F;S架构)，适合作为内部服务使用。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h3><p>SOAP即简单对象访问协议(Simple Object Access Protocol)，是Web Service的通信协议，基于XML文件并绑定在HTTP协议上传递。SOAP消息包括Envelope、Header和Body元素。</p>
<p>一条SOAP消息就是一个普通的XML文档，文档包括下列元素：</p>
<ul>
<li>Envelope元素，必选，可把此XML文档标识为一条SOAP消息</li>
<li>Header元素，可选，包含头部信息</li>
<li>Body元素，必选，包含所有的调用和响应信息</li>
</ul>
<h3 id="WSDL"><a href="#WSDL" class="headerlink" title="WSDL"></a>WSDL</h3><p>Web Service描述语言(SebService Definition Language，简称WSDL)就是用机器能阅读的方式提供的一个正式描述文档而基于XML的语言，用于描述Web Service及其函数、参数和返回值。</p>
<p>在WSDL说明书中，描述了</p>
<ul>
<li>对外发布的服务名称（类）</li>
<li>接口方法名称（方法）</li>
<li>接口参数（方法参数）</li>
<li>​服务返回的数据类型（方法返回值）</li>
</ul>
<h3 id="UDDI"><a href="#UDDI" class="headerlink" title="UDDI"></a>UDDI</h3><p>UDDI(Universal Description，Discovery and Integration)，也就是通用的描述、发现以及整合，是一套基于Web的、分布式的、为WebService提供的、信息注册中心的实现标准规范。用户可以通过UDDI来注册和搜索Web服务。</p>
<h2 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h2><p>面向服务架构(Service Oriented Architecture，简称SOA)，是一个组件模型，它将应用程序的不同功能单元(服务)通过预先定义的接口和契约联系起来。接口是采用中立的方式进行定义的，独立于实现服务的硬件平台、操作系统和编程语言，构建在系统中的服务以一种统一和通用的方式进行交互。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>注: 以下项目基于.NET Framework，.NET中无法使用</p>
<h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>使用ASP.NET Web应用程序(.NET Framework)创建一个Web服务(asmx文件)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Web.Services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplicationDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">WebService(Namespace = <span class="string">&quot;http://tempuri.org/&quot;</span>)</span>] <span class="comment">// 定义命名空间</span></span><br><span class="line">    [<span class="meta">WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)</span>] <span class="comment">// 绑定规范</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebServiceTest</span> : <span class="title">WebService</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">WebMethod(Description = <span class="string">&quot;测试方法&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h2><h3 id="静态引用"><a href="#静态引用" class="headerlink" title="静态引用"></a>静态引用</h3><p>根据提供的Web Service地址，通过Connected Services添加WCF Web服务引用，生成cs文件，然后直接调用。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    WebServiceTestSoapClient client = <span class="keyword">new</span> WebServiceTestSoapClient();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res = client.SumAsync(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(res.Result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射调用"><a href="#反射调用" class="headerlink" title="反射调用"></a>反射调用</h3><p>将Web Service地址存放到配置文件中，通过读取地址生成代理类，动态在项目中生成代理类文件，然后通过反射调用。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res = (<span class="built_in">int</span>)WebServiceProxy.InvokeWebService(<span class="string">&quot;https://localhost:44319/WebServiceTest.asmx&quot;</span>, <span class="string">&quot;WebServiceTest&quot;</span>, <span class="string">&quot;Sum&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 反射代理类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebServiceProxy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">InvokeWebService</span>(<span class="params"><span class="built_in">string</span> url,<span class="built_in">string</span> ns, <span class="built_in">string</span> methodname, <span class="built_in">object</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取WSDL</span></span><br><span class="line">            WebClient wc = <span class="keyword">new</span> WebClient();</span><br><span class="line">            Stream stream = wc.OpenRead(url + <span class="string">&quot;?WSDL&quot;</span>);</span><br><span class="line">            ServiceDescription sd = ServiceDescription.Read(stream);</span><br><span class="line">            <span class="built_in">string</span> classname = sd.Services[<span class="number">0</span>].Name;</span><br><span class="line">            ServiceDescriptionImporter sdi = <span class="keyword">new</span> ServiceDescriptionImporter();</span><br><span class="line">            sdi.AddServiceDescription(sd, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            CodeNamespace cn = <span class="keyword">new</span> CodeNamespace(ns);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成客户端代理类代码</span></span><br><span class="line">            CodeCompileUnit ccu = <span class="keyword">new</span> CodeCompileUnit();</span><br><span class="line">            ccu.Namespaces.Add(cn);</span><br><span class="line">            sdi.Import(cn, ccu);</span><br><span class="line">            CSharpCodeProvider csc = <span class="keyword">new</span> CSharpCodeProvider();</span><br><span class="line">            ICodeCompiler icc = csc.CreateCompiler();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设定编译参数</span></span><br><span class="line">            CompilerParameters cplist = <span class="keyword">new</span> CompilerParameters();</span><br><span class="line">            cplist.GenerateExecutable = <span class="literal">false</span>;</span><br><span class="line">            cplist.GenerateInMemory = <span class="literal">true</span>;</span><br><span class="line">            cplist.ReferencedAssemblies.Add(<span class="string">&quot;System.dll&quot;</span>);</span><br><span class="line">            cplist.ReferencedAssemblies.Add(<span class="string">&quot;System.XML.dll&quot;</span>);</span><br><span class="line">            cplist.ReferencedAssemblies.Add(<span class="string">&quot;System.Web.Services.dll&quot;</span>);</span><br><span class="line">            cplist.ReferencedAssemblies.Add(<span class="string">&quot;System.Data.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//编译代理类</span></span><br><span class="line">            CompilerResults cr = icc.CompileAssemblyFromDom(cplist, ccu);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">true</span> == cr.Errors.HasErrors)</span><br><span class="line">            &#123;</span><br><span class="line">                System.Text.StringBuilder sb = <span class="keyword">new</span> System.Text.StringBuilder();</span><br><span class="line">                <span class="keyword">foreach</span> (System.CodeDom.Compiler.CompilerError ce <span class="keyword">in</span> cr.Errors)</span><br><span class="line">                &#123;</span><br><span class="line">                    sb.Append(ce.ToString());</span><br><span class="line">                    sb.Append(System.Environment.NewLine);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(sb.ToString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成代理实例，并调用方法</span></span><br><span class="line">            System.Reflection.Assembly assembly = cr.CompiledAssembly;</span><br><span class="line">            Type t = assembly.GetType(ns + <span class="string">&quot;.&quot;</span> + classname, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">object</span> obj = Activator.CreateInstance(t);</span><br><span class="line">            System.Reflection.MethodInfo mi = t.GetMethod(methodname);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mi.Invoke(obj, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/?view=netframework-4.8.1">.NET Framework API参考文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Remote-Procedure-Call</category>
      </categories>
      <tags>
        <tag>Web Service</tag>
        <tag>.NET Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Fleck和WebSocket4Net的WebSocket简单实现</title>
    <url>/Hexo-Blog/2024/08/18/websocket-usage/</url>
    <content><![CDATA[<p>WebSocket的基本概念、通信方式，以及OSI七层网络模型，并基于Fleck和WebSocket4Net实现一个简单的即时通讯聊天功能。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>WebSocket是一种在单个TCP连接上进行全双工通信的协议，它可以让客户端和服务器之间进行实时的双向通信。WebSocket使用一个长连接，在客户端和服务器之间保持持久的连接，从而可以实时地发送和接收数据。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h3><p>OSI(Open System Interconnect)七层网络模型是一种将计算机网络体系结构按照功能划分为七层的标准模型。</p>
<ul>
<li>应用层(Application Layer)，负责提供应用程序之间的通信服务，使得不同的应用程序可以在网络上进行数据交换和通信。常见协议有HTTP、HTTPS、FTP、POP3、SSH、DNS等。</li>
<li>表示层(Presentation Layer)，负责处理数据在网络上传输时的格式和编码，以确保不同系统之间的数据交换能够有效地进行。常见协议有JPEG、PNG、MP3等。</li>
<li>会话层(Session Layer)，负责建立、管理和终止应用程序之间的会话。常见协议有SSL等。</li>
<li>传输层(Transport Layer)，负责在不可靠的网络上提供可靠的数据传输服务。常见协议有TCP、UDP等。TCP协议面向连接、可靠，UDP协议无连接、不可靠。</li>
<li>网络层(Network Layer)，负责将数据包从源主机传输到目标主机。常见协议有IP等。</li>
<li>数据链路层(Data Link Layer)，负责将网络层传输过来的数据包进行分帧，并在物理介质上进行传输。常见协议有IEEE802.2(逻辑链路控制标准)、PPP(点对点通信)等。</li>
<li>物理层(Physical Layer)，负责将数字数据转换成物理信号并在网络中传输。常见协议有RS232(串行通信接口标准)、IEEE802.3(以太网标准)等。</li>
</ul>
<h3 id="串口通信与网口通信"><a href="#串口通信与网口通信" class="headerlink" title="串口通信与网口通信"></a>串口通信与网口通信</h3><p>WebSockek有串口、网口两种通信方式。</p>
<ul>
<li><p>串口方式‌主要基于串行接口进行数据传输，采用串口通信协议(如RS232、RS485等)。这种方式适用于点对点的数据传输，使用有限连接，只能连接两台设备，不支持网络中的多台设备之间的通信。串口通信传输速度较慢，传输距离较长，比较稳定，可以确保数据传输的可靠性。</p>
</li>
<li><p>网口方式‌则基于网络通信协议(如TCP&#x2F;IP、UDP等)进行数据传输。这种方式使用无限连接，适用于网络中的多台设备之间的通信。网口通信传输速度较快，传输距离有限。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基于Fleck+WebSocket4Net实现简单通讯聊天。</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>Fleck是C#中的一个WebSocket服务器实现。下面借助Fleck来模拟一个WebSocket服务端。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Fleck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        FleckLog.Level = LogLevel.Debug;</span><br><span class="line">        <span class="keyword">var</span> allSockets = <span class="keyword">new</span> List&lt;IWebSocketConnection&gt;();</span><br><span class="line">        <span class="keyword">var</span> server = <span class="keyword">new</span> WebSocketServer(<span class="string">&quot;ws://127.0.0.1:8181&quot;</span>);</span><br><span class="line">        server.Start(socket =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            socket.OnOpen = () =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line">                allSockets.Add(socket);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;当前客户端数量：&quot;</span> + allSockets.ToList().Count);</span><br><span class="line">            &#125;;</span><br><span class="line">            socket.OnClose = () =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;客户端已经关闭!&quot;</span>);</span><br><span class="line">                allSockets.Remove(socket);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;当前客户端数量：&quot;</span> + allSockets.ToList().Count);</span><br><span class="line">            &#125;;</span><br><span class="line">            socket.OnMessage = message =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(message);</span><br><span class="line">                allSockets.ToList().ForEach(s =&gt; s.Send(message));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line">        <span class="keyword">while</span> (input != <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> socket <span class="keyword">in</span> allSockets.ToList())</span><br><span class="line">            &#123;</span><br><span class="line">                socket.Send(input);</span><br><span class="line">            &#125;</span><br><span class="line">            input = Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>WebSocket4Net是基于.NET的一个WebSocket客户端实现。下面借助WebSocket4Net来模拟一个WebSocket客户端。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> WebSocket4Net;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> WebSocket webSocket4Net = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WebSocket4Net_Opened</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        webSocket4Net.Send(<span class="string">$&quot;客户端连接成功，准备发送数据！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WebSocket4Net_MessageReceived</span>(<span class="params"><span class="built_in">object</span> sender, MessageReceivedEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;服务端回复数据:<span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClientSendMsgToServer</span>(<span class="params"><span class="built_in">object</span> input</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        webSocket4Net.Send((<span class="built_in">string</span>)input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        webSocket4Net = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://127.0.0.1:8181&quot;</span>);</span><br><span class="line">        webSocket4Net.Opened += WebSocket4Net_Opened;</span><br><span class="line">        webSocket4Net.MessageReceived += WebSocket4Net_MessageReceived;</span><br><span class="line">        webSocket4Net.Open();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line">        <span class="keyword">while</span> (input != <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ParameterizedThreadStart(ClientSendMsgToServer));</span><br><span class="line">            thread.Start(input);</span><br><span class="line">            input = Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        webSocket4Net.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a href="https://github.com/statianzo/Fleck">Fleck开源项目地址</a></p>
</li>
<li><p><a href="https://github.com/kerryjiang/WebSocket4Net">WebSocket4Net开源项目地址</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Network-Protocol</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Wix和AutoUpdater的客户端打包与自动更新</title>
    <url>/Hexo-Blog/2024/08/19/wix-toolset-and-autoupdater/</url>
    <content><![CDATA[<p>使用Wix Toolset和AutoUpdater.NET实现Windows桌面应用程序的打包与自动更新功能。</p>
<span id="more"></span>

<h2 id="Wix-Toolset"><a href="#Wix-Toolset" class="headerlink" title="Wix Toolset"></a>Wix Toolset</h2><p>Wix Toolset是用来打包Windows Installer的工具集，通过编译源代码，然后链接以创建可执行文件。WiX命令行构建工具适用于任何自动化构建系统，MSBuild还支持常见的CI&#x2F;CD构建系统，如GitHub Actions。</p>
<p>使用WiX Bundle可以创建安装包来安装先决条件，例如.NET Framework和其他运行时环境以及自己的msi文件。WiX Bundle将他们组合成一个可下载的exe文件。</p>
<p>注: 以下使用的Wix Toolset版本为5.0，与低版本的语法有所区别。在Wix语法中，[]内容为库中预定义的全局变量(安装期间可使用)，$()为用户自己定义的全局变量，!(bind.)为绑定的属性，!(wix.)为Wix编译时的变量(安装期间不可使用)，!(loc.)为本地化之后的内容。</p>
<h3 id="Wix-Package"><a href="#Wix-Package" class="headerlink" title="Wix Package"></a>Wix Package</h3><p>Wix Package的基本功能是将应用程序打包成msi文件。此外，还支持桌面快捷方式、菜单快捷方式、卸载快捷方式添加，开机自启动，引导程序本地化等。</p>
<p>注: 需预先使用NuGet引入依赖包WixToolset.UI、WixToolset.Util</p>
<h4 id="快捷方式添加"><a href="#快捷方式添加" class="headerlink" title="快捷方式添加"></a>快捷方式添加</h4><p>Folders.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Wix</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://wixtoolset.org/schemas/v4/wxs&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 定义桌面快捷方式目录 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">StandardDirectory</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopFolder&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 定义菜单栏快捷方式目录 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">StandardDirectory</span> <span class="attr">Id</span>=<span class="string">&quot;ProgramMenuFolder&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Wix</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Package.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">&lt;!--桌面快捷方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopShortcutComponent&quot;</span> <span class="attr">Guid</span>=<span class="string">&quot;&#123;your-guid&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Shortcut</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopShortcut&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;[INSTALLFOLDER]&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Icon</span>=<span class="string">&quot;&#123;your-icon-name&#125;&quot;</span> <span class="attr">Directory</span>=<span class="string">&quot;DesktopFolder&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">RegistryValue</span> <span class="attr">Root</span>=<span class="string">&quot;HKCU&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\&#123;your-company-name&#125;\&#123;your-product-name&#125;&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Installed&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">KeyPath</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--菜单栏快捷方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">Id</span>=<span class="string">&quot;StartMenuShortcutComponent&quot;</span> <span class="attr">Guid</span>=<span class="string">&quot;&#123;your-guid&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Shortcut</span> <span class="attr">Id</span>=<span class="string">&quot;StartMenuShortcut&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;[INSTALLFOLDER]&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Icon</span>=<span class="string">&quot;&#123;your-icon-name&#125;&quot;</span> <span class="attr">Directory</span>=<span class="string">&quot;ProgramMenuFolder&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">RegistryValue</span> <span class="attr">Root</span>=<span class="string">&quot;HKCU&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\&#123;your-company-name&#125;\&#123;your-product-name&#125;&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Installed&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">KeyPath</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--卸载程序快捷方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">Id</span>=<span class="string">&quot;UninstallShortcutComponent&quot;</span> <span class="attr">Guid</span>=<span class="string">&quot;&#123;your-guid&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Shortcut</span> <span class="attr">Id</span>=<span class="string">&quot;UninstallProduct&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Uninstall&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;[SystemFolder]msiexec.exe&quot;</span> <span class="attr">Arguments</span>=<span class="string">&quot;/x [ProductCode]&quot;</span> <span class="attr">Icon</span>=<span class="string">&quot;UninstallIcon&quot;</span> <span class="attr">Description</span>=<span class="string">&quot;Uninstall &#123;your-product-name&#125;.&quot;</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">RegistryValue</span> <span class="attr">Id</span>=<span class="string">&quot;RegUninstallShortcut&quot;</span> <span class="attr">Root</span>=<span class="string">&quot;HKCU&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\&#123;your-company-name&#125;\&#123;your-product-name&#125;&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;UninstallShortcut&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;&quot;</span> <span class="attr">KeyPath</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="快捷方式图标设置"><a href="#快捷方式图标设置" class="headerlink" title="快捷方式图标设置"></a>快捷方式图标设置</h4><p>Package.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- 引用应用程序图标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">Id</span>=<span class="string">&quot;&#123;your-icon-name&#125;&quot;</span> <span class="attr">SourceFile</span>=<span class="string">&quot;$(var.&#123;your-product-name&#125;.ProjectDir)Resources\icon.ico&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引用卸载图标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">Id</span>=<span class="string">&quot;UninstallIcon&quot;</span> <span class="attr">SourceFile</span>=<span class="string">&quot;$(var.&#123;your-product-name&#125;.ProjectDir)Resources\uninstall.ico&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制面板引用应用程序图标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">Id</span>=<span class="string">&quot;ARPPRODUCTICON&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;&#123;your-icon-name&#125;&quot;</span> /&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h4><p>Package.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">Id</span>=<span class="string">&quot;Register&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RegistryKey</span> <span class="attr">ForceCreateOnInstall</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">Id</span>=<span class="string">&quot;AutoStartKey&quot;</span> <span class="attr">Root</span>=<span class="string">&quot;HKLM&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Run&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RegistryValue</span> <span class="attr">Id</span>=<span class="string">&quot;AutoStartKeyValue&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">KeyPath</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;[INSTALLFOLDER]&#123;your-product-name&#125;.exe&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RegistryValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RegistryKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="卸载或更改前自动关闭程序进程"><a href="#卸载或更改前自动关闭程序进程" class="headerlink" title="卸载或更改前自动关闭程序进程"></a>卸载或更改前自动关闭程序进程</h4><p>Package.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--卸载或更改前关闭程序进程--&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">Id</span>=<span class="string">&quot;TASKKILL&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">DirectorySearch</span> <span class="attr">Id</span>=<span class="string">&quot;SysDir&quot;</span> <span class="attr">Path</span>=<span class="string">&quot;[SystemFolder]&quot;</span> <span class="attr">Depth</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">FileSearch</span> <span class="attr">Id</span>=<span class="string">&quot;taskkillExe&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;taskkill.exe&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">DirectorySearch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">util:CloseApplication</span> <span class="attr">Id</span>=<span class="string">&quot;CloseApp&quot;</span> <span class="attr">CloseMessage</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">RebootPrompt</span>=<span class="string">&quot;no&quot;</span>  <span class="attr">PromptToContinue</span>=<span class="string">&quot;yes&quot;</span>  <span class="attr">Description</span>=<span class="string">&quot;!(loc.CloseBeforeUninstall)&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">CustomAction</span> <span class="attr">Id</span>=<span class="string">&quot;WixCloseApplications&quot;</span> <span class="attr">Property</span>=<span class="string">&quot;TASKKILL&quot;</span> <span class="attr">Execute</span>=<span class="string">&quot;immediate&quot;</span> <span class="attr">Impersonate</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">Return</span>=<span class="string">&quot;ignore&quot;</span> <span class="attr">ExeCommand</span>=<span class="string">&quot;/F /FI <span class="symbol">&amp;quot;</span>IMAGENAME eq &#123;your-product-name&#125;.exe<span class="symbol">&amp;quot;</span>&quot;</span>/&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Package.zh-cn.wxl</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">WixLocalization</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://wixtoolset.org/schemas/v4/wxl&quot;</span> <span class="attr">Culture</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="tag">&lt;<span class="name">String</span> <span class="attr">Id</span>=<span class="string">&quot;CloseBeforeUninstall&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;请关闭应用程序后再进行卸载!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">String</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">WixLocalization</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="x86和x64平台区分可执行文件源"><a href="#x86和x64平台区分可执行文件源" class="headerlink" title="x86和x64平台区分可执行文件源"></a>x86和x64平台区分可执行文件源</h4><p>Package.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Package</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">Manufacturer</span>=<span class="string">&quot;$(var.Manufacturer)&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;!(bind.FileVersion.ExeFile_m2)&quot;</span> <span class="attr">UpgradeCode</span>=<span class="string">&quot;$(var.UpgradeCode)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MajorUpgrade</span> <span class="attr">DowngradeErrorMessage</span>=<span class="string">&quot;!(loc.DowngradeError)&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">MediaTemplate</span> <span class="attr">EmbedCab</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Files</span> <span class="attr">Include</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)\**&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Exclude</span> <span class="attr">Files</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)\&#123;your-product-name&#125;.exe&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Exclude</span> <span class="attr">Files</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)\&#123;your-product-name&#125;_x86.exe&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Exclude</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Files</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">Id</span>=<span class="string">&quot;ExeFile_m2&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Source</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)&#123;your-product-name&#125;_x86.exe&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;NOT VersionNT64&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">Id</span>=<span class="string">&quot;ExeFile_m1&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Source</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;VersionNT64&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Package</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="Wix-Bundle"><a href="#Wix-Bundle" class="headerlink" title="Wix Bundle"></a>Wix Bundle</h3><p>Wix Bundle主要用于设置系统必备组件，如各种依赖环境，可以根据目标平台区分依赖的安装包版本。此外还可引入主题文件，定制个性化安装界面。</p>
<p>注: 需预先使用NuGet引入依赖包WixToolset.BootstrapperApplications、WixToolset.Netfx、WixToolset.Util</p>
<h4 id="设置系统必备组件"><a href="#设置系统必备组件" class="headerlink" title="设置系统必备组件"></a>设置系统必备组件</h4><p>以下以.NET Core 6.0运行时和WebEdge WebView2运行时为例</p>
<p>Bundle.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Chain</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Define the .NET Core Runtime 6.0 dependency --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">PackageGroupRef</span> <span class="attr">Id</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_t&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Define the Edge WebView2 Runtime dependency --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">PackageGroupRef</span> <span class="attr">Id</span>=<span class="string">&quot;WV_bootstrapper&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Other packages can be added here --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">MsiPackage</span> <span class="attr">Id</span>=<span class="string">&quot;MainPackage&quot;</span> <span class="attr">Compressed</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">SourceFile</span>= <span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)\zh-CN\&#123;your-product-name&#125;.msi&quot;</span> <span class="attr">Visible</span>=<span class="string">&quot;no&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">MsiProperty</span> <span class="attr">Name</span>=<span class="string">&quot;INSTALLFOLDER&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;[InstallFolder]&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">MsiPackage</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Chain</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Define the package group for .NET Core Runtime 6.0 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">netfx:DotNetCoreSearch</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">RuntimeType</span>=<span class="string">&quot;desktop&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">Platform</span>=<span class="string">&quot;x86&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">MajorVersion</span>=<span class="string">&quot;6&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">Variable</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x86&quot;</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">	<span class="tag">&lt;<span class="name">netfx:DotNetCoreSearch</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">RuntimeType</span>=<span class="string">&quot;desktop&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">Platform</span>=<span class="string">&quot;x64&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">MajorVersion</span>=<span class="string">&quot;6&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">Variable</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x64&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">WixVariable</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopNetCoreRuntime_6029_Redist_DetectCondition_x86&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x86&quot;</span> <span class="attr">Overridable</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">WixVariable</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopNetCoreRuntime_6029_Redist_DetectCondition_x64&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x64&quot;</span> <span class="attr">Overridable</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">PackageGroup</span> <span class="attr">Id</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_t&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ExePackage</span> <span class="attr">Id</span>=<span class="string">&quot;NetCoreRuntime6_x86&quot;</span> <span class="attr">Cache</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">Permanent</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">PerMachine</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">		 	<span class="attr">DetectCondition</span>=<span class="string">&quot;!(wix.DesktopNetCoreRuntime_6029_Redist_DetectCondition_x86)&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">InstallCondition</span>=<span class="string">&quot;NOT VersionNT64&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">InstallArguments</span>=<span class="string">&quot;/install /quiet&quot;</span>&gt;</span> <span class="comment">&lt;!-- 设置静默安装 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ExePackagePayload</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Name</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x86&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Size</span>=<span class="string">&quot;&#123;file-size&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">DownloadUrl</span>=<span class="string">&quot;&#123;dowload-url&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Hash</span>=<span class="string">&quot;&#123;file-hash&#125;&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ExePackage</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">ExePackage</span> <span class="attr">Id</span>=<span class="string">&quot;NetCoreRuntime6_x64&quot;</span> <span class="attr">Cache</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">Permanent</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">PerMachine</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">		 	<span class="attr">DetectCondition</span>=<span class="string">&quot;!(wix.DesktopNetCoreRuntime_6029_Redist_DetectCondition_x64)&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">InstallCondition</span>=<span class="string">&quot;VersionNT64&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">InstallArguments</span>=<span class="string">&quot;/install /quiet&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ExePackagePayload</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Name</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x64&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Size</span>=<span class="string">&quot;&#123;file-size&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">DownloadUrl</span>=<span class="string">&quot;&#123;dowload-url&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Hash</span>=<span class="string">&quot;&#123;file-hash&#125;&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ExePackage</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">PackageGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- Define the package group for Edge WebView2 Runtime --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">util:RegistrySearch</span> <span class="attr">Root</span>=<span class="string">&quot;HKLM&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\Microsoft\EdgeUpdate\Clients\&#123;F3017226-FE2A-4295-8BDF-00C3A9A7E4C5&#125;&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;pv&quot;</span> <span class="attr">Variable</span>=<span class="string">&quot;WVRTInstalled_x86&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">util:RegistrySearch</span> <span class="attr">Root</span>=<span class="string">&quot;HKLM&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\WOW6432Node\Microsoft\EdgeUpdate\Clients\&#123;F3017226-FE2A-4295-8BDF-00C3A9A7E4C5&#125;&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;pv&quot;</span> <span class="attr">Variable</span>=<span class="string">&quot;WVRTInstalled_x64&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">WixVariable</span> <span class="attr">Id</span>=<span class="string">&quot;WV_DetectCondition_x86&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;WVRTInstalled_x86&quot;</span> <span class="attr">Overridable</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">WixVariable</span> <span class="attr">Id</span>=<span class="string">&quot;WV_DetectCondition_x64&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;WVRTInstalled_x64&quot;</span> <span class="attr">Overridable</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">PackageGroup</span> <span class="attr">Id</span>=<span class="string">&quot;WV_bootstrapper&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ExePackage</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Id</span>=<span class="string">&quot;WV_bootstrapper_x86&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">PerMachine</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">DetectCondition</span>=<span class="string">&quot;!(wix.WV_DetectCondition_x86)&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">InstallCondition</span>=<span class="string">&quot;NOT VersionNT64&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Vital</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Permanent</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Cache</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">CacheId</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ExePackagePayload</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Name</span>=<span class="string">&quot;WV_bootstrapper_x86&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">DownloadUrl</span>=<span class="string">&quot;&#123;dowload-url&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Hash</span>=<span class="string">&quot;&#123;file-hash&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Size</span>=<span class="string">&quot;&#123;file-size&#125;&quot;</span>  /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ExePackage</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">ExePackage</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Id</span>=<span class="string">&quot;WV_bootstrapper_x64&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">PerMachine</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">DetectCondition</span>=<span class="string">&quot;!(wix.WV_DetectCondition_x64)&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">InstallCondition</span>=<span class="string">&quot;VersionNT64&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Vital</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Permanent</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Cache</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">CacheId</span>=<span class="string">&quot;2&quot;</span>&gt;</span> </span><br><span class="line">			<span class="tag">&lt;<span class="name">ExePackagePayload</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Name</span>=<span class="string">&quot;WV_bootstrapper_x64&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">DownloadUrl</span>=<span class="string">&quot;&#123;dowload-url&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Hash</span>=<span class="string">&quot;&#123;file-hash&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Size</span>=<span class="string">&quot;&#123;file-size&#125;&quot;</span>  /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ExePackage</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">PackageGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="定制个性化安装界面"><a href="#定制个性化安装界面" class="headerlink" title="定制个性化安装界面"></a>定制个性化安装界面</h4><p>注意: CustomTheme.xml定义了安装窗口、页面、按钮等各种UI元素以及样式、响应事件，CustomLocalize.wxl定义了个性化文本内容，具体可参照<a href="https://github.com/wixtoolset/wix">Wix Toolset源码</a></p>
<p>Bundle.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Bundle</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">Manufacturer</span>=<span class="string">&quot;$(var.Manufacturer)&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Version</span>=<span class="string">&quot;!(bind.packageVersion.MainPackage)&quot;</span> <span class="attr">UpgradeCode</span>=<span class="string">&quot;$(var.UpgradeCode)&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">IconSourceFile</span>=<span class="string">&quot;$(var.&#123;your-product-name&#125;.ProjectDir)Resources\&#123;your-company-name&#125;.ico&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BootstrapperApplication</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bal:WixStandardBootstrapperApplication</span> <span class="attr">LicenseUrl</span>=<span class="string">&quot;&quot;</span> <span class="attr">Theme</span>=<span class="string">&quot;rtfLargeLicense&quot;</span> <span class="attr">ShowVersion</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">LogoFile</span> =<span class="string">&quot;$(var.&#123;your-product-name&#125;.ProjectDir)Resources\&#123;your-company-name&#125;.ico&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ThemeFile</span>=<span class="string">&quot;CustomTheme.xml&quot;</span> <span class="attr">LocalizationFile</span>=<span class="string">&quot;CustomLocalize.wxl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">BootstrapperApplication</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Bundle</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="AutoUpdater-NET"><a href="#AutoUpdater-NET" class="headerlink" title="AutoUpdater.NET"></a>AutoUpdater.NET</h2><p>AutoUpdater.NET是一个类库，可让.NET开发人员轻松地将自动更新功能添加到桌面应用程序项目中。AutoUpdater.NET会从服务器下载包含更新信息的XML文件。它使用该XML文件获取软件最新版本的信息。如果软件的最新版本大于用户PC上安装的软件的当前版本，AutoUpdater.NET就会向用户显示更新对话框。如果用户按下更新按钮更新软件，它就会从XML文件中提供的URL下载更新文件（安装程序），并执行刚刚下载的安装程序文件。此后，安装程序的工作就是执行更新。如果您提供的是zip文件URL而不是安装程序，AutoUpdater.NET将把zip文件的内容解压缩到应用程序目录。</p>
<h3 id="配置XML"><a href="#配置XML" class="headerlink" title="配置XML"></a>配置XML</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>&#123;latest-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>&#123;your-download-url&#125;<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">changelog</span>&gt;</span>&#123;your-changelog-url&#125;<span class="tag">&lt;/<span class="name">changelog</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mandatory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">mandatory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="启动更新检查"><a href="#启动更新检查" class="headerlink" title="启动更新检查"></a>启动更新检查</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">AutoUpdater.Start(<span class="string">&quot;&#123;your-xml-url&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="手动处理更新"><a href="#手动处理更新" class="headerlink" title="手动处理更新"></a>手动处理更新</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">AutoUpdater.CheckForUpdateEvent += AutoUpdaterOnCheckForUpdateEvent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">AutoUpdaterOnCheckForUpdateEvent</span>(<span class="params">UpdateInfoEventArgs args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.IsUpdateAvailable)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> log = <span class="keyword">await</span> httpClient.GetStringAsync(args.ChangelogURL);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> textContent = <span class="string">$&quot;当前版本<span class="subst">&#123;args.InstalledVersion&#125;</span>, 最新版本<span class="subst">&#123;args.CurrentVersion&#125;</span>\n&quot;</span> +</span><br><span class="line">                              <span class="string">&quot;有新版本可用，是否立即更新？\n&quot;</span> + <span class="string">$&quot;<span class="subst">&#123;log&#125;</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">            MessageBoxResult result = MessageBox.Show(textContent, <span class="string">&quot;更新提示&quot;</span>, MessageBoxButton.YesNo, MessageBoxImage.Information);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result == MessageBoxResult.Yes)</span><br><span class="line">            &#123;</span><br><span class="line">                Close();</span><br><span class="line">                AutoUpdater.DownloadUpdate(args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (HttpRequestException e)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(e.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a href="https://wixtoolset.org/docs/intro/">Wix Toolset官方文档</a></p>
</li>
<li><p><a href="https://github.com/wixtoolset/wix">Wix Toolset开源项目地址</a></p>
</li>
<li><p><a href="https://github.com/ravibpatel/AutoUpdater.NET">AutoUpdater.NET开源项目地址</a></p>
</li>
<li><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/msi/properties">Windows Installer在安装期间使用的全局变量</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Package-Tool</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Wix Toolset</tag>
      </tags>
  </entry>
</search>
